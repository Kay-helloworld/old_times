# 資料庫建立與維護完整流程指南

> **目標**：協助您全面掌握資料庫從規劃到維護的完整生命週期  
> **參考來源**：基於地方特考三等資料庫應用歷年考古題與解析

---

## 📋 目錄

1. [階段一：需求分析與概念設計](#階段一需求分析與概念設計)
2. [階段二：邏輯設計與正規化](#階段二邏輯設計與正規化)
3. [階段三：建立資料庫與綱要](#階段三建立資料庫與綱要)
4. [階段四：建立表格與約束](#階段四建立表格與約束)
5. [階段五：新增資料](#階段五新增資料)
6. [階段六：查詢與維護](#階段六查詢與維護)
7. [階段七：進階維護與優化](#階段七進階維護與優化)
8. [完整範例演練](#完整範例演練)

---

## 🎯 整體流程概覽

```
需求收集  →  ER設計  →  正規化  →  建立DB  →  建立綱要  →  建立表格  →  
新增資料  →  查詢測試  →  建立索引  →  安全設定  →  備份維護
```

---

## 階段一：需求分析與概念設計

### 1.1 需求收集

**目標**：了解業務需求，識別實體、屬性、關聯。

**步驟**：

1. **訪談使用者**，了解需要管理哪些資料
2. **識別實體（Entity）**：例如：學生、課程、訂單
3. **識別屬性（Attribute）**：例如：學號、姓名、出生日期
4. **識別關聯（Relationship）**：例如：學生「選課」課程

**範例情境**：

> 美美藥妝店需要管理：
> - 顧客資料（顧客編號、姓名、住址、手機）
> - 商品資料（商品編號、名稱、種類、單價）
> - 供應商資料（廠商編號、名稱、住址、電話）
> - 訂單資料（訂單編號、日期、數量、備註）

---

### 1.2 繪製 ER Diagram（實體關係圖）

**符號說明**：

| 符號 | 意義 |
|------|------|
| 長方形 | 實體（Entity） |
| 橢圓形 | 屬性（Attribute） |
| 菱形 | 關聯（Relationship） |
| 底線 | 主鍵（Primary Key） |
| 雙橢圓 | 多值屬性（Multi-valued） |

**基數標示**：

- **1:1** (One-to-One)：一對一
- **1:N** (One-to-Many)：一對多
- **M:N** (Many-to-Many)：多對多

**範例 ER Diagram（文字描述）**：

```
Customer (客戶)
  屬性：CustomerID (PK), Name, Address, Phone
  
Product (商品)
  屬性：ProductID (PK), Name, Type, Price
  
Supplier (供應商)
  屬性：SupplierID (PK), Name, Address, Phone
  
Order (訂單)
  屬性：OrderID (PK), Date, Quantity, Note

關聯：
  Customer --< Order (1:N)  ← 一個客戶可有多張訂單
  Order >-- Product (N:1)   ← 一張訂單對應一個商品（簡化情況）
  Supplier --< Product (1:N) ← 一個供應商供應多種商品
```

---

### 1.3 EER 進階設計（選用）

**適用情境**：有繼承、類別、聚合需求時。

**EER 特有元素**：

#### **⑴ Supertype/Subtype（超類別/子類別）**

**範例**：

```
Person (超類別)
  ├─ PoliceOfficer (子類別)：Rank, DateHired
  └─ Civilian (子類別)：Occupation
```

#### **⑵ 特殊化（Specialization）**

- **Disjoint（互斥）**：子類別之間不重疊（例如：員工只能是正職或兼職）
- **Overlapping（重疊）**：子類別可重疊（例如：員工可以同時是工程師和經理）

#### **⑶ 完全性約束**

- **Total Participation（完全參與）**：超類別的每個實例都必須屬於某個子類別
- **Partial Participation（部分參與）**：超類別可以不屬於任何子類別

**考試重點**：

- 會畫出 IS-A 關係圖
- 說明繼承的屬性
- 標示 Disjoint/Overlapping

---

## 階段二：邏輯設計與正規化

### 2.1 ER Model 轉換為 Relational Schema

**轉換規則**：

#### **規則1：實體轉換**

每個實體型態（Entity Type）轉換為一個關聯（Relation）。

```sql
Customer (CustomerID, Name, Address, Phone)
            ↑ PK
```

---

#### **規則2：1:N 關聯轉換**

將 "1" 那一方的主鍵，加入到 "N" 那一方作為**外來鍵（Foreign Key）**。

**範例**：

```
Supplier --< Product (1:N)

轉換後：
  Supplier (SupplierID, Name, Address, Phone)
  Product (ProductID, Name, Type, Price, SupplierID)
                                          ↑ FK
```

---

#### **規則3：M:N 關聯轉換**

建立一個**新的關聯表**，包含兩邊的主鍵作為**複合主鍵（Composite Key）**。

**範例**：

```
Student >--< Course (M:N) - 關聯屬性：Grade

轉換後：
  Student (StudentID, Name)
  Course (CourseID, CourseName)
  Enrollment (StudentID, CourseID, Grade)
              ↑───────────────────↑ Composite PK
```

---

#### **規則4：1:1 關聯轉換**

**方法一**：合併兩個實體（若參與度是完全參與）  
**方法二**：將任一方的主鍵加入另一方作為 FK（並設為 UNIQUE）

---

#### **規則5：多值屬性（Multi-valued Attribute）**

建立一個新表，主鍵為原實體PK + 該屬性。

**範例**：

```
Employee 有多值屬性 Phone

轉換後：
  Employee (EmployeeID, Name)
  EmployeePhone (EmployeeID, Phone)
                 ↑─────────────↑ Composite PK
```

---

### 2.2 正規化（Normalization）

**目標**：消除資料重複、更新異常（Update Anomaly）。

#### **第一正規形式（1NF）**

**定義**：每個欄位都是**原子值（Atomic Value）**，不可再分割。

**違反範例**：

| 學號 | 姓名 | 電話 |
|------|------|------|
| S001 | 王小明 | 0912-345678, 02-1234567 | ← 違反！電話有多個值

**修正**：

| 學號 | 姓名 | 電話 |
|------|------|------|
| S001 | 王小明 | 0912-345678 |
| S001 | 王小明 | 02-1234567 |

---

#### **第二正規形式（2NF）**

**定義**：
1. 符合 1NF
2. 所有非鍵屬性**完全功能相依**於主鍵（消除部分相依）

**違反範例**：

```
選課表(學號, 課程編號, 成績, 姓名, 系別)
         ↑────────↑ Composite PK

FD:
  {學號, 課程編號} → 成績  ✓（完全相依）
  學號 → 姓名              ✗（部分相依，只需學號即可決定姓名）
  學號 → 系別              ✗（部分相依）
```

**問題**：
- 更新異常：若要修改學生姓名，需修改多筆記錄
- 插入異常：新生尚未選課，無法新增學生資料

**修正**：分解成兩個表

```sql
學生表(學號, 姓名, 系別)         ← PK: 學號
選課表(學號, 課程編號, 成績)     ← PK: {學號, 課程編號}
```

---

#### **第三正規形式（3NF）**

**定義**：
1. 符合 2NF
2. 所有非鍵屬性**不遞移相依**於主鍵

**違反範例**：

```
員工表(員工編號, 部門編號, 部門名稱)

FD:
  員工編號 → 部門編號
  部門編號 → 部門名稱
  ∴ 員工編號 → 部門名稱（遞移相依）✗
```

**修正**：

```sql
員工表(員工編號, 部門編號)       ← FK: 部門編號
部門表(部門編號, 部門名稱)       ← PK: 部門編號
```

---

#### **BCNF（Boyce-Codd Normal Form）**

**定義**：對於每個非平凡的 FD: X→Y，X 必須是超鍵（Superkey）。

**白話文**：所有決定因素都必須是候選鍵。

**考試技巧**：

1. 找出所有候選鍵
2. 檢查每個 FD 的左側是否為超鍵
3. 若否，則違反 BCNF

---

### 2.3 驗證分解的正確性

#### **⑴ Lossless Join（無失真連接）**

**定義**：分解後的表格透過自然連接（Natural Join）能完整還原原表。

**判定方法**：

對於分解 R1, R2，若滿足以下任一條件則為 Lossless：

```
(R1 ∩ R2)+ ⊇ R1  或  (R1 ∩ R2)+ ⊇ R2
```

**範例**：

```
R(A, B, C)，FD: A→B
分解為 R1(A, B) 和 R2(A, C)

檢查：
  R1 ∩ R2 = {A}
  {A}+ = {A, B}  ⊇  R1 ✓
  
∴ 此分解為 Lossless Join
```

---

#### **⑵ Dependency Preservation（相依性保持）**

**定義**：原始的所有 FD 都能在分解後的表格中被檢查。

**範例**：

```
R(A, B, C)，FD: {A→B, B→C, A→C}
分解為 R1(A, B) 和 R2(B, C)

檢查：
  - A→B 可在 R1 檢查 ✓
  - B→C 可在 R2 檢查 ✓
  - A→C 需透過 JOIN 才能檢查 ✗（但可由 A→B→C 推導）
  
∴ 此分解保持相依性
```

---

## 階段三：建立資料庫與綱要

### 3.1 建立資料庫（Database）

**SQL 語法**：

```sql
-- 建立資料庫
CREATE DATABASE DrugStore
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_unicode_ci;

-- 查看現有資料庫
SHOW DATABASES;

-- 選擇要使用的資料庫
USE DrugStore;
```

**重要參數**：

| 參數 | 說明 | 常用值 |
|------|------|--------|
| `CHARACTER SET` | 字元編碼 | utf8mb4（支援完整Unicode，包含emoji） |
| `COLLATE` | 排序規則 | utf8mb4_unicode_ci（不區分大小寫） |

---

### 3.2 建立綱要（Schema）

**注意**：在 MySQL 中，**Database 就是 Schema**，無需額外建立。  
**在其他 DBMS（如 PostgreSQL、Oracle）中**：

```sql
-- PostgreSQL 建立 Schema
CREATE SCHEMA sales;

-- 在特定 Schema 中建立表格
CREATE TABLE sales.Customer (...);

-- 設定預設 Schema
SET search_path TO sales;
```

---

## 階段四：建立表格與約束

### 4.1 建立表格（CREATE TABLE）

**基本語法**：

```sql
CREATE TABLE table_name (
    column1 datatype [constraint],
    column2 datatype [constraint],
    ...
    [table_constraint]
);
```

---

### 4.2 資料型態（Data Types）

#### **數值型態**

| 型態 | 說明 | 範例 |
|------|------|------|
| `INT` / `INTEGER` | 整數（-2,147,483,648 ~ 2,147,483,647） | 年齡、數量 |
| `BIGINT` | 大整數 | 訂單編號 |
| `DECIMAL(p, s)` | 精確小數（p位數，s小數位） | 金額 DECIMAL(10,2) |
| `FLOAT` / `DOUBLE` | 浮點數（不精確） | 科學計算 |

#### **字串型態**

| 型態 | 說明 | 範例 |
|------|------|------|
| `CHAR(n)` | 固定長度字串 | 身分證字號 CHAR(10) |
| `VARCHAR(n)` | 可變長度字串 | 姓名 VARCHAR(50) |
| `TEXT` | 長文字 | 備註、描述 |

#### **日期時間型態**

| 型態 | 格式 | 範例 |
|------|------|------|
| `DATE` | YYYY-MM-DD | 2025-01-15 |
| `DATETIME` | YYYY-MM-DD HH:MM:SS | 2025-01-15 14:30:00 |
| `TIMESTAMP` | 時間戳記（自動更新） | 記錄建立/修改時間 |

---

### 4.3 約束條件（Constraints）

#### **⑴ PRIMARY KEY（主鍵）**

**特性**：
- 唯一識別每一筆資料
- 自動具備 `NOT NULL` + `UNIQUE`
- 一個表格只能有一個 PRIMARY KEY

**語法**：

```sql
-- 方法1：在欄位定義時指定
CREATE TABLE Customer (
    CustomerID INT PRIMARY KEY,
    Name VARCHAR(50)
);

-- 方法2：在表格層級指定（適用複合主鍵）
CREATE TABLE Enrollment (
    StudentID INT,
    CourseID INT,
    Grade CHAR(2),
    PRIMARY KEY (StudentID, CourseID)  ← 複合主鍵
);
```

---

#### **⑵ FOREIGN KEY（外來鍵）**

**目的**：確保參考完整性（Referential Integrity）。

**語法**：

```sql
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    OrderDate DATE,
    
    FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID)
);
```

**參考動作（Referential Actions）**：

| 動作 | 父表刪除時 | 子表行為 |
|------|-----------|---------|
| `CASCADE` | DELETE | 一併刪除子表對應記錄 |
| `SET NULL` | DELETE | 子表外來鍵設為 NULL |
| `RESTRICT` / `NO ACTION` | DELETE | **拒絕刪除**（預設） |

**範例**：

```sql
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    
    FOREIGN KEY (CustomerID) 
        REFERENCES Customer(CustomerID)
        ON DELETE CASCADE           ← 客戶刪除，訂單也刪除
        ON UPDATE CASCADE           ← 客戶ID更新,訂單也更新
);
```

---

#### **⑶ UNIQUE（唯一性約束）**

**用途**：確保欄位值不重複（但允許 NULL）。

```sql
CREATE TABLE Employee (
    EmployeeID INT PRIMARY KEY,
    Email VARCHAR(100) UNIQUE,      ← Email 不可重複
    SSN CHAR(10) UNIQUE             ← 身分證字號不可重複
);
```

---

#### **⑷ NOT NULL（非空約束）**

```sql
CREATE TABLE Product (
    ProductID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,     ← 名稱不可為空
    Price DECIMAL(10,2) NOT NULL    ← 價格不可為空
);
```

---

#### **⑸ CHECK（檢查約束）**

**用途**：限制欄位值的範圍。

```sql
CREATE TABLE Employee (
    EmployeeID INT PRIMARY KEY,
    Age INT CHECK (Age >= 18 AND Age <= 65),
    Salary DECIMAL(10,2) CHECK (Salary > 0),
    Gender CHAR(1) CHECK (Gender IN ('M', 'F'))
);
```

---

#### **⑹ DEFAULT（預設值）**

```sql
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    OrderDate DATE DEFAULT CURRENT_DATE,    ← 預設今天
    Status VARCHAR(20) DEFAULT 'Pending'    ← 預設狀態
);
```

---

### 4.4 實際建表範例

**完整範例：美美藥妝店**

```sql
-- 1. 客戶表
CREATE TABLE Customer (
    CustomerID INT PRIMARY KEY AUTO_INCREMENT,
    Name VARCHAR(50) NOT NULL,
    Address VARCHAR(200),
    Phone VARCHAR(20) UNIQUE
);

-- 2. 供應商表
CREATE TABLE Supplier (
    SupplierID INT PRIMARY KEY AUTO_INCREMENT,
    Name VARCHAR(100) NOT NULL,
    Address VARCHAR(200),
    Phone VARCHAR(20)
);

-- 3. 商品表
CREATE TABLE Product (
    ProductID INT PRIMARY KEY AUTO_INCREMENT,
    Name VARCHAR(100) NOT NULL,
    Type VARCHAR(50),
    Price DECIMAL(10,2) NOT NULL CHECK (Price >= 0),
    SupplierID INT,
    
    FOREIGN KEY (SupplierID) 
        REFERENCES Supplier(SupplierID)
        ON DELETE SET NULL
);

-- 4. 訂單表
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY AUTO_INCREMENT,
    OrderDate DATE DEFAULT CURRENT_DATE,
    Quantity INT CHECK (Quantity > 0),
    Note TEXT,
    CustomerID INT NOT NULL,
    ProductID INT NOT NULL,
    
    FOREIGN KEY (CustomerID) 
        REFERENCES Customer(CustomerID)
        ON DELETE CASCADE,
    FOREIGN KEY (ProductID) 
        REFERENCES Product(ProductID)
        ON DELETE RESTRICT
);
```

---

## 階段五:新增資料

### 5.1 INSERT 語法

#### **⑴ 插入單筆資料**

```sql
-- 方法1：指定欄位（建議）
INSERT INTO Customer (Name, Address, Phone)
VALUES ('王小明', '台北市信義區', '0912-345678');

-- 方法2：依表格欄位順序（不建議，容易出錯）
INSERT INTO Customer
VALUES (NULL, '李小華', '新北市板橋區', '0923-456789');
```

---

#### **⑵ 插入多筆資料**

```sql
INSERT INTO Product (Name, Type, Price, SupplierID)
VALUES 
    ('維他命C', '保健食品', 350.00, 1),
    ('面膜', '美妝用品', 199.00, 2),
    ('感冒糖漿', '藥品', 120.00, 1);
```

---

#### **⑶ 從其他表格複製資料**

```sql
-- 將舊客戶資料複製到新表
INSERT INTO NewCustomer (CustomerID, Name, Phone)
SELECT CustomerID, Name, Phone
FROM OldCustomer
WHERE RegisterDate >= '2023-01-01';
```

---

### 5.2 資料新增注意事項

**順序原則**：**先新增父表（被參考的表），再新增子表（參考別人的表）**。

**錯誤範例**：

```sql
-- ✗ 錯誤！SupplierID = 999 不存在於 Supplier 表
INSERT INTO Product (Name, Price, SupplierID)
VALUES ('商品A', 100, 999);

-- 錯誤訊息：
-- ERROR: Cannot add or update a child row: 
-- a foreign key constraint fails
```

**正確順序**：

```sql
-- 1. 先新增供應商（父表）
INSERT INTO Supplier (SupplierID, Name)
VALUES (999, '新供應商');

-- 2. 再新增商品（子表）
INSERT INTO Product (Name, Price, SupplierID)
VALUES ('商品A', 100, 999);
```

---

### 5.3 匯入大量資料

#### **⑴ LOAD DATA（MySQL）**

```sql
LOAD DATA LOCAL INFILE '/path/to/data.csv'
INTO TABLE Customer
FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n'
IGNORE 1 ROWS;  -- 忽略標題列
```

---

#### **⑵ 使用工具**

- **MySQL Workbench**：Table Data Import Wizard
- **phpMyAdmin**：匯入功能
- **命令列**：`mysql -u username -p database < data.sql`

---

## 階段六：查詢與維護

### 6.1 基本查詢（SELECT）

#### **⑴ 簡單查詢**

```sql
-- 查詢所有客戶
SELECT * FROM Customer;

-- 查詢特定欄位
SELECT Name, Phone FROM Customer;

-- 條件篩選
SELECT * FROM Product WHERE Price > 100;

-- 排序
SELECT * FROM Product ORDER BY Price DESC;

-- 限制筆數
SELECT * FROM Product LIMIT 10;
```

---

#### **⑵ 聚合函數**

```sql
-- 統計客戶數量
SELECT COUNT(*) AS 客戶總數 FROM Customer;

-- 計算平均價格
SELECT AVG(Price) AS 平均價格 FROM Product;

-- 找出最高價
SELECT MAX(Price) AS 最高價 FROM Product;

-- 分組統計（每個供應商的商品數量）
SELECT SupplierID, COUNT(*) AS 商品數量
FROM Product
GROUP BY SupplierID;

-- 分組後篩選（商品數量超過5的供應商）
SELECT SupplierID, COUNT(*) AS 商品數量
FROM Product
GROUP BY SupplierID
HAVING COUNT(*) > 5;
```

---

#### **⑶ JOIN（連接查詢）**

**INNER JOIN（內連接）**：只保留兩表都有的資料

```sql
-- 查詢商品及其供應商名稱
SELECT P.Name AS 商品名稱, S.Name AS 供應商名稱, P.Price
FROM Product P
INNER JOIN Supplier S ON P.SupplierID = S.SupplierID;
```

**LEFT JOIN（左外連接）**：保留左表所有資料

```sql
-- 查詢所有客戶及其訂單（包含沒有訂單的客戶）
SELECT C.Name, O.OrderID, O.OrderDate
FROM Customer C
LEFT JOIN Orders O ON C.CustomerID = O.CustomerID;
```

---

### 6.2 資料修改（UPDATE）

```sql
-- 修改單筆資料
UPDATE Product
SET Price = 399.00
WHERE ProductID = 1;

-- 批次修改（所有保健食品打9折）
UPDATE Product
SET Price = Price * 0.9
WHERE Type = '保健食品';
```

**⚠️ 注意**：務必加上 `WHERE` 條件，否則會修改所有資料！

---

### 6.3 資料刪除（DELETE）

```sql
-- 刪除特定資料
DELETE FROM Customer
WHERE CustomerID = 100;

-- 刪除所有資料（保留表格結構）
DELETE FROM Orders;

-- 清空表格（更快，但無法復原）
TRUNCATE TABLE Orders;
```

**外來鍵限制影響**：

```sql
-- 若 Orders 有參考 Customer(CustomerID)
-- 且設定為 ON DELETE RESTRICT，則無法刪除有訂單的客戶

DELETE FROM Customer WHERE CustomerID = 1;
-- ERROR: Cannot delete or update a parent row: 
-- a foreign key constraint fails
```

**解決方法**：

1. 先刪除子表資料（Orders）
2. 再刪除父表資料（Customer）
3. 或者使用 `ON DELETE CASCADE`

---

## 階段七：進階維護與優化

### 7.1 建立 View（視圖）

**目的**：
- 簡化複雜查詢
- 提升資料安全性
- 提供邏輯資料獨立性

**語法**：

```sql
-- 建立「高價商品」視圖
CREATE VIEW HighPriceProducts AS
SELECT ProductID, Name, Price, Type
FROM Product
WHERE Price > 500;

-- 使用視圖（就像查詢一般表格）
SELECT * FROM HighPriceProducts;
```

**安全性應用**：

```sql
-- 建立「公開客戶資訊」視圖（隱藏電話）
CREATE VIEW PublicCustomerInfo AS
SELECT CustomerID, Name, Address
FROM Customer;

-- 授權一般使用者僅能查詢此視圖
GRANT SELECT ON PublicCustomerInfo TO general_user;
```

---

### 7.2 建立索引（Index）

**目的**：加速查詢效能。

**語法**：

```sql
-- 在單一欄位建立索引
CREATE INDEX idx_product_name ON Product(Name);

-- 在多個欄位建立複合索引
CREATE INDEX idx_order_customer_date 
ON Orders(CustomerID, OrderDate);

-- 建立唯一索引
CREATE UNIQUE INDEX idx_customer_email 
ON Customer(Email);

-- 查看索引
SHOW INDEX FROM Product;

-- 刪除索引
DROP INDEX idx_product_name ON Product;
```

#### **何時需要建立索引？**

✅ **適合建立索引**：
- 經常用於 `WHERE` 條件的欄位
- 經常用於 `JOIN` 的欄位
- 經常用於 `ORDER BY` 的欄位
- 資料量大（> 1000筆）

❌ **不適合建立索引**：
- 資料量小的表格
- 經常被 `UPDATE`/`INSERT`/`DELETE` 的欄位
- 欄位值重複性高（例如：性別只有 M/F）

---

### 7.3 建立 Stored Procedure（預存程序）

**目的**：
- 封裝複雜商業邏輯
- 減少網路傳輸
- 提升效能
- 增強安全性

**語法**：

```sql
DELIMITER //

CREATE PROCEDURE GetCustomerOrders(IN customer_id INT)
BEGIN
    SELECT O.OrderID, O.OrderDate, P.Name AS ProductName, O.Quantity
    FROM Orders O
    JOIN Product P ON O.ProductID = P.ProductID
    WHERE O.CustomerID = customer_id
    ORDER BY O.OrderDate DESC;
END //

DELIMITER ;

-- 呼叫預存程序
CALL GetCustomerOrders(1);
```

**帶有交易控制的範例**：

```sql
DELIMITER //

CREATE PROCEDURE ProcessOrder(
    IN p_customer_id INT,
    IN p_product_id INT,
    IN p_quantity INT
)
BEGIN
    DECLARE stock_available INT;
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SELECT 'Error: Transaction rolled back' AS Message;
    END;
    
    START TRANSACTION;
    
    -- 檢查庫存
    SELECT Stock INTO stock_available 
    FROM Product 
    WHERE ProductID = p_product_id;
    
    IF stock_available >= p_quantity THEN
        -- 扣除庫存
        UPDATE Product 
        SET Stock = Stock - p_quantity 
        WHERE ProductID = p_product_id;
        
        -- 新增訂單
        INSERT INTO Orders (CustomerID, ProductID, Quantity, OrderDate)
        VALUES (p_customer_id, p_product_id, p_quantity, CURRENT_DATE);
        
        COMMIT;
        SELECT 'Order processed successfully' AS Message;
    ELSE
        ROLLBACK;
        SELECT 'Error: Insufficient stock' AS Message;
    END IF;
END //

DELIMITER ;
```

---

### 7.4 建立 Trigger（觸發程序）

**目的**：自動執行特定動作，維護資料完整性。

**語法**：

```sql
-- 範例：新增訂單時，自動扣除商品庫存
DELIMITER //

CREATE TRIGGER trg_after_order_insert
AFTER INSERT ON Orders
FOR EACH ROW
BEGIN
    UPDATE Product
    SET Stock = Stock - NEW.Quantity
    WHERE ProductID = NEW.ProductID;
END //

DELIMITER ;
```

**記錄修改歷史**：

```sql
-- 先建立歷史表
CREATE TABLE Product_History (
    HistoryID INT PRIMARY KEY AUTO_INCREMENT,
    ProductID INT,
    OldPrice DECIMAL(10,2),
    NewPrice DECIMAL(10,2),
    ChangeDate DATETIME
);

-- 建立觸發程序
DELIMITER //

CREATE TRIGGER trg_product_price_change
AFTER UPDATE ON Product
FOR EACH ROW
BEGIN
    IF OLD.Price != NEW.Price THEN
        INSERT INTO Product_History (ProductID, OldPrice, NewPrice, ChangeDate)
        VALUES (NEW.ProductID, OLD.Price, NEW.Price, NOW());
    END IF;
END //

DELIMITER ;
```

---

### 7.5 交易管理（Transaction）

**ACID 特性**：

| 特性 | 英文 | 說明 |
|------|------|------|
| **原子性** | Atomicity | 全部成功或全部失敗 |
| **一致性** | Consistency | 維持資料完整性 |
| **隔離性** | Isolation | 並行交易互不干擾 |
| **持久性** | Durability | 已提交的交易永久保存 |

**語法**：

```sql
-- 開始交易
START TRANSACTION;

-- 執行多個操作
UPDATE Account SET Balance = Balance - 1000 WHERE AccountID = 1;
UPDATE Account SET Balance = Balance + 1000 WHERE AccountID = 2;

-- 確認提交
COMMIT;

-- 若出錯，可復原
ROLLBACK;
```

---

### 7.6 使用者權限管理

#### **⑴ 建立使用者**

```sql
CREATE USER 'sales_user'@'localhost' 
IDENTIFIED BY 'password123';
```

---

#### **⑵ 授予權限**

```sql
-- 授予查詢權限
GRANT SELECT ON DrugStore.* TO 'sales_user'@'localhost';

-- 授予完整權限
GRANT ALL PRIVILEGES ON DrugStore.* TO 'admin_user'@'localhost';

-- 授予特定表格的特定權限
GRANT SELECT, INSERT ON DrugStore.Orders TO 'sales_user'@'localhost';

-- 授予執行預存程序的權限
GRANT EXECUTE ON PROCEDURE GetCustomerOrders TO 'sales_user'@'localhost';

-- 套用權限
FLUSH PRIVILEGES;
```

---

#### **⑶ 撤銷權限**

```sql
REVOKE INSERT ON DrugStore.Orders FROM 'sales_user'@'localhost';
```

---

#### **⑷ 刪除使用者**

```sql
DROP USER 'sales_user'@'localhost';
```

---

### 7.7 備份與還原

#### **⑴ 完整備份（使用 mysqldump）**

```bash
# 備份單一資料庫
mysqldump -u root -p DrugStore > drugstore_backup.sql

# 備份所有資料庫
mysqldump -u root -p --all-databases > all_databases_backup.sql

# 備份特定表格
mysqldump -u root -p DrugStore Customer Orders > tables_backup.sql
```

---

#### **⑵ 還原備份**

```bash
# 還原資料庫
mysql -u root -p DrugStore < drugstore_backup.sql

# 或在 MySQL 內執行
SOURCE /path/to/drugstore_backup.sql;
```

---

#### **⑶ 自動化備份（Linux Cron）**

```bash
# 編輯 crontab
crontab -e

# 每天凌晨2點自動備份
0 2 * * * /usr/bin/mysqldump -u root -pYourPassword DrugStore > /backup/drugstore_$(date +\%Y\%m\%d).sql
```

---

### 7.8 資料庫效能監控與優化

#### **⑴ 查看慢查詢**

```sql
-- 開啟慢查詢日誌（my.cnf）
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow-query.log
long_query_time = 2  -- 超過2秒記錄

-- 查看慢查詢
SELECT * FROM mysql.slow_log;
```

---

#### **⑵ 使用 EXPLAIN 分析查詢**

```sql
EXPLAIN SELECT * FROM Orders WHERE CustomerID = 1;
```

**重點欄位**：

| 欄位 | 說明 |
|------|------|
| `type` | 連接類型（const > eq_ref > ref > range > index > ALL） |
| `possible_keys` | 可能使用的索引 |
| `key` | 實際使用的索引 |
| `rows` | 預估掃描行數 |
| `Extra` | 額外資訊（Using index = 優；Using filesort = 需優化） |

---

#### **⑶ 優化建議**

1. **為 WHERE、JOIN 欄位建立索引**
2. **避免 SELECT ***，只查詢需要的欄位
3. **使用 LIMIT 限制結果數量**
4. **適當的正規化（避免過度或不足）**
5 **定期執行 OPTIMIZE TABLE** 重整表格

```sql
OPTIMIZE TABLE Orders;
```

---

## 完整範例演練

### 情境：建立學生選課系統

#### **步驟1：需求分析**

**實體**：
- 學生（Student）：學號、姓名、系別
- 課程（Course）：課程編號、課程名稱、學分
- 教師（Teacher）：教師編號、姓名、職稱
- 選課記錄（Enrollment）：學生選哪門課、成績

**關聯**：
- 學生 >--< 課程（M:N）
- 教師 --< 課程（1:N）

---

#### **步驟2：ER Model 設計**

```
Student (學號, 姓名, 系別)
Course (課程編號, 課程名稱, 學分, 教師編號)
Teacher (教師編號, 姓名, 職稱)
Enrollment (學號, 課程編號, 成績)
```

---

#### **步驟3：建立資料庫**

```sql
CREATE DATABASE University
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_unicode_ci;

USE University;
```

---

#### **步驟4：建立表格**

```sql
-- 1. 教師表（父表）
CREATE TABLE Teacher (
    TeacherID CHAR(5) PRIMARY KEY,
    Name VARCHAR(50) NOT NULL,
    Title VARCHAR(20)
);

-- 2. 課程表
CREATE TABLE Course (
    CourseID CHAR(6) PRIMARY KEY,
    CourseName VARCHAR(100) NOT NULL,
    Credits INT CHECK (Credits > 0),
    TeacherID CHAR(5),
    
    FOREIGN KEY (TeacherID) 
        REFERENCES Teacher(TeacherID)
        ON DELETE SET NULL
);

-- 3. 學生表（父表）
CREATE TABLE Student (
    StudentID CHAR(9) PRIMARY KEY,
    Name VARCHAR(50) NOT NULL,
    Department VARCHAR(50)
);

-- 4. 選課表（子表）
CREATE TABLE Enrollment (
    StudentID CHAR(9),
    CourseID CHAR(6),
    Grade CHAR(2),
    
    PRIMARY KEY (StudentID, CourseID),
    FOREIGN KEY (StudentID) REFERENCES Student(StudentID) ON DELETE CASCADE,
    FOREIGN KEY (CourseID) REFERENCES Course(CourseID) ON DELETE CASCADE
);
```

---

#### **步驟5：新增資料**

```sql
-- 1. 新增教師
INSERT INTO Teacher VALUES 
    ('T001', '張三教授', '教授'),
    ('T002', '李四副教授', '副教授');

-- 2. 新增課程
INSERT INTO Course VALUES 
    ('CS101', '資料庫系統', 3, 'T001'),
    ('CS102', '資料結構', 3, 'T002');

-- 3. 新增學生
INSERT INTO Student VALUES 
    ('S10001001', '王小明', '資訊工程系'),
    ('S10001002', '李小華', '資訊工程系');

-- 4. 新增選課記錄
INSERT INTO Enrollment VALUES 
    ('S10001001', 'CS101', 'A'),
    ('S10001001', 'CS102', 'B'),
    ('S10001002', 'CS101', 'A+');
```

---

#### **步驟6：查詢範例**

```sql
-- 查詢王小明的所有選課記錄
SELECT S.Name, C.CourseName, E.Grade
FROM Student S
JOIN Enrollment E ON S.StudentID = E.StudentID
JOIN Course C ON E.CourseID = C.CourseID
WHERE S.Name = '王小明';

-- 查詢每門課程的選課人數
SELECT C.CourseName, COUNT(*) AS 選課人數
FROM Course C
LEFT JOIN Enrollment E ON C.CourseID = E.CourseID
GROUP BY C.CourseID, C.CourseName;
```

---

#### **步驟7：建立視圖**

```sql
CREATE VIEW StudentCourseView AS
SELECT 
    S.StudentID,
    S.Name AS StudentName,
    C.CourseID,
    C.CourseName,
    T.Name AS TeacherName,
    E.Grade
FROM Student S
JOIN Enrollment E ON S.StudentID = E.StudentID
JOIN Course C ON E.CourseID = C.CourseID
JOIN Teacher T ON C.TeacherID = T.TeacherID;

-- 使用視圖
SELECT * FROM StudentCourseView WHERE StudentName = '王小明';
```

---

#### **步驟8：建立索引**

```sql
-- 為常用查詢欄位建立索引
CREATE INDEX idx_student_name ON Student(Name);
CREATE INDEX idx_course_name ON Course(CourseName);
```

---

## 🎓 知識檢查清單

完成這份指南後，您應該能夠：

### ✅ 概念設計階段
- [ ] 識別實體、屬性、關聯
- [ ] 繪製 ER Diagram
- [ ] 理解 EER 進階元素（Supertype/Subtype）

### ✅ 邏輯設計階段
- [ ] 將 ER Model 轉換為 Relational Schema
- [ ] 理解 1NF、2NF、3NF、BCNF
- [ ] 計算屬性封閉（Closure）
- [ ] 找出候選鍵（Candidate Key）
- [ ] 判斷 Lossless Join 和 Dependency Preservation

### ✅ 實作階段
- [ ] 建立資料庫（CREATE DATABASE）
- [ ] 建立表格（CREATE TABLE）
- [ ] 設定主鍵、外來鍵、約束條件
- [ ] 新增資料（INSERT）
- [ ] 查詢資料（SELECT、JOIN、GROUP BY）
- [ ] 修改資料（UPDATE）
- [ ] 刪除資料（DELETE）

### ✅ 進階維護
- [ ] 建立 View（視圖）
- [ ] 建立 Index（索引）
- [ ] 建立 Stored Procedure（預存程序）
- [ ] 建立 Trigger（觸發程序）
- [ ] 管理交易（ACID、COMMIT、ROLLBACK）
- [ ] 管理使用者權限
- [ ] 備份與還原資料庫
- [ ] 使用 EXPLAIN 優化查詢

---

## 📚 延伸學習資源

### 相關解析文件
- `01_SQL_and_Programming_ANALYSIS.md` - SQL 語法詳解
- `02_Database_Design_ANALYSIS.md` - ER Model 與設計
- `03_Normalization_Theory_ANALYSIS.md` - 正規化理論
- `04_Transaction_Management_ANALYSIS.md` - 交易管理
- `06_Administration_Security_ANALYSIS.md` - 管理與安全

### 考試準備建議

1. **優先熟悉 SQL 語法**（佔考題 45%）
2. **ER Model 轉換要熟練**（佔考題 30%）
3. **正規化理論要理解**（佔考題 25%）
4. **多練習實際案例**

---

## 🎯 最後提醒

### 建立資料庫的正確順序

```
需求分析 → ER設計 → 正規化 → 建立資料庫 → 建立綱要（Schema）→ 
建立表格 → 新增資料 → 建立索引 → 建立View/SP/Trigger → 
權限管理 → 備份維護
```

### 考試常見陷阱

1. **主鍵與外來鍵順序**：一定要先建立被參考的表（父表）
2. **ON DELETE CASCADE**：了解刪除連鎖效應
3. **NULL 值處理**：注意 `COALESCE()` 的使用
4. **GROUP BY 完整性**：SELECT 的非聚合欄位都要在 GROUP BY 中
5. **HAVING vs WHERE**：聚合後篩選用 HAVING，聚合前用 WHERE

---

**祝您考試順利！** 🎉

如有任何問題，請參考同目錄下的其他解析文件。
