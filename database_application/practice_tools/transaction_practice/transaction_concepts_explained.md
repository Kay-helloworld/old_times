# 交易管理完全攻略 - 白話文版

這份文件會用**最簡單的方式**解釋交易管理的所有核心概念。保證你看完就懂！

---

## 第一部分：什麼是交易？

### 📌 最核心的概念

**交易 (Transaction)** 就是一組「必須一起完成」的資料庫操作。

#### 🏦 經典例子：ATM 轉帳

假設你要從帳戶 A 轉 1000 元到帳戶 B：

```
步驟1: 從 A 扣掉 1000 元
步驟2: 在 B 加上 1000 元
```

**問題來了**：如果步驟1成功了，但步驟2失敗了（例如停電），會發生什麼事？
- A 的錢少了 1000
- B 的錢沒有增加
- **錢憑空消失了！**

**解決方案**：把這兩個步驟包成一個「交易」
```sql
BEGIN TRANSACTION;  -- 開始交易
    UPDATE Account SET balance = balance - 1000 WHERE id = 'A';
    UPDATE Account SET balance = balance + 1000 WHERE id = 'B';
COMMIT;  -- 確認完成（或 ROLLBACK 全部取消）
```

#### 交易的三個關鍵字

1. **BEGIN TRANSACTION** (或 START TRANSACTION)
   - 意思：「我要開始一連串操作了，請記住這些步驟」
   
2. **COMMIT**
   - 意思：「我確認要執行這些步驟，請正式寫入資料庫」
   - 一旦 COMMIT，就無法反悔
   
3. **ROLLBACK**
   - 意思：「出錯了！請把剛才的所有步驟都取消」
   - 回到 BEGIN 之前的狀態

#### 🎯 核心理解

**交易 = 要麼全做，要麼全不做**

就像你在玩遊戲存檔：
- COMMIT = 確認存檔
- ROLLBACK = 讀取上次存檔

---

## 第二部分：ACID 特性

ACID 是交易管理的「黃金守則」，每個字母代表一個保證。

### A = Atomicity (原子性)

#### 💡 白話解釋
「原子性」就是「不可分割性」。交易就像一顆原子，不能只做一半。

#### 🎮 生活比喻：遊戲存檔
- 你在玩遊戲，打了一個 BOSS，獲得 3 個獎勵
- 如果只給你 1 個獎勵就存檔，這不合理
- **原子性保證**：要麼 3 個獎勵都給你，要麼都不給（繼續打 BOSS）

#### 📊 技術實現
- 靠「Log（日誌）」實現
- 如果交易中途失敗，系統會查日誌，把已做的步驟「倒回去」

#### ❌ 違反原子性的後果
```
轉帳交易失敗：
- A 扣了 1000 元 ✓
- B 加了 0 元 ✗
結果：錢憑空消失
```

---

### C = Consistency (一致性)

#### 💡 白話解釋
「一致性」就是「規則不能被破壞」。資料庫有一些「不變的定律」，交易執行後這些定律必須依然成立。

#### 🏦 銀行例子
**不變定律**：所有帳戶的總金額 = 固定值（錢不能憑空產生或消失）

```
交易前：A有1000, B有500, 總額=1500
轉帳：A轉300給B
交易後：A有700, B有800, 總額=1500 ✓

如果交易後總額變成1200，就違反一致性 ✗
```

#### 🎯 其他例子
- **學生選課系統**：課程人數 ≤ 教室容量
- **訂票系統**：已售票數 ≤ 總座位數

#### ⚠️ 重點
一致性是「應用邏輯」的責任，不是資料庫自動做的。你要在交易裡寫對的 SQL，資料庫才能保證一致性。

---

### I = Isolation (隔離性)

#### 💡 白話解釋
「隔離性」就是「多個交易同時執行時，彼此不會互相干擾」。

#### 🚻 廁所比喻
- 廁所有 3 個隔間
- 3 個人同時使用，但彼此看不到對方在做什麼
- 每個人都覺得自己「獨享」廁所

#### 🏦 沒有隔離性的災難

**情境**：兩個人同時轉帳給同一個帳戶

```
時間 | 交易T1 (轉500)          | 交易T2 (轉300)
-----|-------------------------|---------------------------
t1   | 讀取 balance = 1000     |
t2   |                         | 讀取 balance = 1000 (錯誤！應該等T1)
t3   | 計算 1000 + 500 = 1500  |
t4   |                         | 計算 1000 + 300 = 1300
t5   | 寫入 balance = 1500     |
t6   |                         | 寫入 balance = 1300 (覆蓋！)
```

**結果**：T1 的 +500 不見了！這叫做 **Lost Update (更新遺失)**

#### 🛡️ 如何實現隔離性？
用「鎖 (Lock)」。想像每個資料都有一把鎖：
- 要讀資料？先拿鑰匙
- 要寫資料？先拿鑰匙，而且別人不能同時拿

---

### D = Durability (持久性)

#### 💡 白話解釋
「持久性」就是「一旦 COMMIT，資料永遠不會消失」，即使停電、當機也一樣。

#### 💾 比喻：刻在石碑上
- COMMIT 之前：資料只在「草稿紙」上
- COMMIT 之後：資料刻在「石碑」上，永遠不會消失

#### ⚡ 技術實現
- 靠「Log（日誌）」+ 定期寫入硬碟
- Log 是「備份的備份」，即使硬碟壞了，也能從 Log 恢復

#### 🎯 考試重點
如果題目問「停電後資料會不會不見？」
- 如果已經 COMMIT → 不會不見（Durability）
- 如果還沒 COMMIT → 會不見（Atomicity 會 ROLLBACK）

---

## 第三部分：並行控制問題

當多個交易「同時」執行時，如果沒有管制，會出現以下問題：

### 問題1: Lost Update (更新遺失)

#### 📖 情境
兩個人同時編輯同一個 Word 文件
- A 改了第 5 行
- B 也改了第 5 行
- 如果 B 後存檔，A 的修改就不見了

#### 💻 資料庫例子（前面講過）
```
T1: 讀 balance=1000 → 寫 balance=1500
T2: 讀 balance=1000 → 寫 balance=1300 (覆蓋！)
```

---

### 問題2: Dirty Read (髒讀)

#### 💡 白話解釋
「髒讀」就是「讀到還沒確定的資料」。

#### 🛒 購物例子
```
時間 | T1 (你在買東西)          | T2 (庫存系統)
-----|--------------------------|---------------------------
t1   | BEGIN                    |
t2   | 庫存 = 10, 下單買 5      |
t3   | 庫存改成 5 (還沒COMMIT)  |
t4   |                          | 讀到庫存=5 (髒讀！)
t5   | ROLLBACK (取消訂單)     |
t6   |                          | 以為庫存只剩5，實際是10
```

**問題**：T2 讀到了 T1「還沒確定」的資料，導致判斷錯誤。

---

### 問題3: Non-Repeatable Read (不可重複讀)

#### 💡 白話解釋
「同一筆資料，讀兩次卻得到不同的值」。

#### 📊 報表例子
```
時間 | T1 (產生報表)            | T2 (修改資料)
-----|--------------------------|---------------------------
t1   | 讀取 A 帳戶 = 1000      |
t2   |                          | A 帳戶改成 1500, COMMIT
t3   | 再讀取 A 帳戶 = 1500 (?)|
```

**問題**：T1 的報表自相矛盾（同一個帳戶，前後數字不一樣）

---

### 問題4: Phantom Read (幻讀)

#### 💡 白話解釋
「查詢結果的『筆數』前後不一致」。

#### 🎓 點名例子
```
時間 | T1 (統計學生人數)        | T2 (新生註冊)
-----|--------------------------|---------------------------
t1   | 查詢學生數 = 50          |
t2   |                          | 新增 1 個學生, COMMIT
t3   | 再查詢學生數 = 51 (?)   |
```

**問題**：T1 第一次數到 50 人，第二次變 51 人（就像看到「幻影」）

---

## 第四部分：鎖定機制 (Locking)

鎖就像「使用權」的控制。

### 鎖的兩種類型

#### 1. Shared Lock (S-Lock, 共享鎖) = 「只看不動」

**用途**：讀取資料時加鎖

**規則**：
- 多個交易可以「同時」持有 S-Lock（大家一起看沒關係）
- 持有 S-Lock 時，不能有人持有 X-Lock（有人在看，就不能改）

**比喻**：圖書館的書
- 可以多人同時閱讀（共享）
- 但不能有人在塗改（排他）

#### 2. Exclusive Lock (X-Lock, 排他鎖) = 「我要改，別人別碰」

**用途**：寫入/修改資料時加鎖

**規則**：
- 只有一個交易可以持有 X-Lock（獨占）
- 持有 X-Lock 時，別人不能有任何鎖（我在改，你們都別看）

**比喻**：廁所隔間
- 一次只能一個人用（排他）
- 別人只能在外面等

---

### 鎖的相容性表

```
        | 已有S-Lock | 已有X-Lock
--------|-----------|------------
要S-Lock|    ✓      |     ✗
要X-Lock|    ✗      |     ✗
```

**白話解釋**：
- ✓ = 可以拿到鎖
- ✗ = 必須等待

**例子**：
- 資料 A 目前有人拿了 S-Lock（在讀）
- 你想拿 S-Lock（也讀）→ OK ✓
- 你想拿 X-Lock（要寫）→ NO ✗，請等人家讀完

---

### Two-Phase Locking (2PL)

#### 💡 核心規則
交易的加鎖過程分兩階段：

**Phase 1: Growing (成長階段)**
- 只能「加鎖」
- 不能「釋放鎖」

**Phase 2: Shrinking (縮小階段)**
- 只能「釋放鎖」
- 不能「加鎖」

#### 📊 時間線圖
```
交易T1:
|-------- Growing --------|------ Shrinking ------|
 加鎖A  加鎖B  加鎖C       釋放A  釋放B  釋放C
                ↑
            這是「轉折點」
            之後只能釋放，不能再加鎖
```

#### 🎯 為什麼要這樣？
**保證「可序列化 (Serializable)」**

意思是：雖然多個交易同時執行，但結果就像「一個接一個執行」一樣正確。

#### ❌ 不遵守 2PL 的後果
```
交易T1:
 加鎖A → 釋放A → 加鎖B (違反2PL！)
                   ↑
            Phase 2 不應該再加鎖
```
可能導致 **Non-Serializable** 的排程，產生前面講的 Lost Update 等問題。

---

## 第五部分：死結 (Deadlock)

### 💡 什麼是死結？

**白話解釋**：兩個交易互相等對方釋放鎖，形成「我等你，你等我」的僵局。

#### 🚗 停車場比喻

```
情境：狹窄巷子，兩台車相遇

車A：我在等車B倒車讓路
車B：我在等車A倒車讓路

結果：兩台車都卡住，永遠等不到
```

#### 💻 資料庫例子

```
時間 | T1                      | T2
-----|-------------------------|---------------------------
t1   | 取得 A 的 X-Lock        |
t2   |                         | 取得 B 的 X-Lock
t3   | 想要 B 的 X-Lock (等待)  |
t4   |                         | 想要 A 的 X-Lock (等待)
```

**結果**：
- T1 等 T2 釋放 B
- T2 等 T1 釋放 A
- **兩個都在等，永遠等不到！**

---

### 死結的四個必要條件

死結必須「同時滿足」以下四個條件：

#### 1. Mutual Exclusion (互斥)
**意思**：資源一次只能給一個人用（例如 X-Lock）

#### 2. Hold and Wait (持有並等待)
**意思**：我拿著鎖 A，同時等待鎖 B

#### 3. No Preemption (不能搶奪)
**意思**：不能強制別人釋放鎖

#### 4. Circular Wait (循環等待)
**意思**：T1→T2→T1 形成等待的環

#### 🎯 重點
**破壞任何一個條件，就能避免死結**

---

### 如何處理死結？

#### 方法1: 預防 (Prevention)
**策略**：事先規定「加鎖順序」

```
規定：所有交易都必須「先鎖 A，再鎖 B」

這樣就不會出現：
- T1: 先A後B
- T2: 先B後A (這會導致死結)
```

**破壞了哪個條件？** → Circular Wait（不會形成環）

#### 方法2: 偵測與恢復 (Detection & Recovery)

**步驟**：
1. 用 **Wait-For Graph** 偵測死結
2. 犧牲一個交易（ROLLBACK），解除死結

**Wait-For Graph 範例**：
```
T1 → T2  (T1 等待 T2)
T2 → T1  (T2 等待 T1)

形成環 → 有死結！
```

---

## 第六部分：恢復機制 (Recovery)

### 💡 為什麼需要恢復？

**三種失敗情境**：
1. **交易失敗**：執行中發生錯誤（例如除以零）
2. **系統當機**：停電、作業系統崩潰
3. **硬碟損壞**：物理故障

**目標**：無論發生什麼事，都要能「回到正確狀態」

---

### Log (日誌)

#### 💡 白話解釋
Log 就像「操作紀錄簿」，記錄每一步做了什麼。

#### 📝 Log 的內容

```
<T1, START>                        -- T1 開始
<T1, A, old=1000, new=1500>        -- T1 修改 A: 1000→1500
<T1, B, old=500, new=200>          -- T1 修改 B: 500→200
<T1, COMMIT>                       -- T1 確認完成
```

#### ⚙️ Write-Ahead Logging (WAL)

**核心規則**：「先寫 Log，再改資料」

```
步驟1: 把「A要從1000改成1500」寫進Log
步驟2: 真正去改資料庫的A
```

**為什麼？**
- 如果步驟2時當機，Log 還在，可以重做
- 如果先改資料再寫Log，當機就什麼都沒了

---

### Checkpoint (檢查點)

#### 💡 白話解釋
Checkpoint 就像遊戲的「自動存檔點」。

#### 🎮 為什麼需要？

```
沒有Checkpoint:
系統當機 → 要從「第一筆Log」開始掃描 → 很慢

有Checkpoint:
系統當機 → 只要從「最後一個Checkpoint」開始掃描 → 快很多
```

#### ⚙️ Checkpoint 的動作

```
1. 暫停所有新交易
2. 把所有已COMMIT的變更寫入硬碟
3. 寫一筆 <CHECKPOINT> 到Log
4. 繼續接受新交易
```

---

### ARIES 演算法

這是考試最常考的恢復演算法，分三個步驟：

#### Phase 1: Analysis (分析)
**目的**：找出哪些交易需要處理

**動作**：
- 從最後一個 Checkpoint 開始掃描 Log
- 分類交易：
  - 已 COMMIT → 需要 **Redo**（重做）
  - 未 COMMIT → 需要 **Undo**（撤銷）

#### Phase 2: Redo (重做)
**目的**：恢復已 COMMIT 但還沒寫入硬碟的變更

**動作**：
- 照著 Log 重新執行一次
- 確保「已確認的交易不會消失」（Durability）

#### Phase 3: Undo (撤銷)
**目的**：撤銷未 COMMIT 的交易

**動作**：
- 把未完成的交易「倒著做回去」
- 確保「未確認的交易不會影響資料庫」（Atomicity）

---

### 🎯 實際例子

**Log 內容**：
```
<T1, START>
<T1, A, 100, 200>
<T1, COMMIT>
<T2, START>
<T2, B, 50, 80>
<CHECKPOINT>
<T3, START>
<T3, C, 10, 20>
<T3, COMMIT>
<T2, D, 30, 40>
*** 系統當機 ***
```

**恢復步驟**：

1. **Analysis**：
   - T1: COMMIT ✓ → Redo
   - T2: 沒COMMIT ✗ → Undo
   - T3: COMMIT ✓ → Redo

2. **Redo**：
   - T1: A=200
   - T3: C=20

3. **Undo**：
   - T2: D 保持原值(30), B 保持原值(50)

**最終結果**：
- A = 200 (T1的修改保留)
- B = 50 (T2的修改取消)
- C = 20 (T3的修改保留)
- D = 30 (T2的修改取消)

---

## 總結：核心重點整理

### ACID 一句話記憶
- **A (Atomicity)**：要麼全做，要麼全不做
- **C (Consistency)**：規則不能被破壞
- **I (Isolation)**：多人同時用，彼此不干擾
- **D (Durability)**：COMMIT 後永遠不消失

### 並行問題
- **Lost Update**：你的修改被別人覆蓋
- **Dirty Read**：讀到還沒確定的資料
- **Non-Repeatable Read**：同一筆資料，讀兩次不一樣
- **Phantom Read**：查詢筆數前後不一致

### 鎖
- **S-Lock**：讀取用，可共享
- **X-Lock**：寫入用，必須獨占
- **2PL**：先加鎖，再釋放鎖（不能交錯）

### 死結
- **定義**：互相等待，卡死
- **四個條件**：互斥、持有等待、不能搶奪、循環等待
- **解決**：預防（統一順序）或偵測（犧牲一個）

### 恢復
- **WAL**：先寫 Log，再改資料
- **Checkpoint**：加速恢復
- **ARIES**：Analysis → Redo → Undo

---

## 🎯 下一步

看完這份文件後，你應該：
1. ✅ 理解為什麼需要交易
2. ✅ 能解釋 ACID 四個特性
3. ✅ 知道並行控制的四個問題
4. ✅ 理解鎖的運作方式
5. ✅ 知道死結怎麼發生、怎麼解決
6. ✅ 理解系統當機後如何恢復

**現在可以開始做題了！**

需要我：
- 從 112-114 年考題中篩選交易管理題目？
- 針對某個概念做更多練習（例如畫 Wait-For Graph）？
- 建立一個資料集讓你在 DBeaver 實際體驗並行問題？
