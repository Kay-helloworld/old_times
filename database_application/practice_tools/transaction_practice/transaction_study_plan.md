# 交易管理 (Transaction Management) 初學者學習計畫

根據考題分析，交易管理在 **114年暴增至73次**，是資料庫考試的重點科目。這份學習計畫將帶你從零開始掌握這個領域。

---

## 📚 學習路徑總覽

```
第一週：基礎概念 → 第二週：並行控制 → 第三週：恢復機制 → 第四週：實戰演練
```

---

## 第一週：基礎概念與 ACID

### Day 1-2: 什麼是交易 (Transaction)？

**核心概念**：
- 交易是一系列「不可分割」的資料庫操作
- 要麼全部成功 (Commit)，要麼全部失敗 (Rollback)

**經典例子**：銀行轉帳
```sql
BEGIN TRANSACTION;
    UPDATE Account SET balance = balance - 1000 WHERE id = 'A'; -- 扣款
    UPDATE Account SET balance = balance + 1000 WHERE id = 'B'; -- 入款
COMMIT; -- 或 ROLLBACK;
```

**為什麼需要交易？**
- 如果扣款成功但入款失敗，錢就憑空消失了！
- 交易保證「原子性」：全做或全不做。

**學習任務**：
1. 理解 `BEGIN`, `COMMIT`, `ROLLBACK` 的作用
2. 寫下 3 個生活中需要交易保護的場景（例如：訂票系統、購物車結帳）

---

### Day 3-4: ACID 特性

這是交易管理的核心！每個字母都代表一個保證：

#### **A = Atomicity (原子性)**
- **定義**：交易是「不可分割」的最小單位
- **比喻**：像原子一樣，不能只執行一半
- **例子**：轉帳要嘛兩個步驟都做，要嘛都不做

#### **C = Consistency (一致性)**
- **定義**：交易執行前後，資料庫必須維持「一致狀態」
- **比喻**：規則不能被破壞
- **例子**：總金額守恆定律（A扣1000 + B加1000 = 總額不變）

#### **I = Isolation (隔離性)**
- **定義**：多個交易「同時」執行時，彼此不應互相干擾
- **比喻**：每個人都以為自己在獨享資料庫
- **例子**：你在轉帳，別人同時也在轉帳，不應該互相影響

#### **D = Durability (持久性)**
- **定義**：交易一旦 Commit，結果必須「永久保存」
- **比喻**：寫入石碑，即使停電也不會消失
- **例子**：轉帳成功後，即使系統當機，錢也不會不見

**學習任務**：
1. 用自己的話解釋 ACID（不要照抄定義）
2. 為每個特性舉一個「違反它會發生什麼問題」的例子

---

## 第二週：並行控制 (Concurrency Control)

### Day 5-7: 為什麼需要並行控制？

**問題場景**：兩個人同時轉帳給同一個帳戶
```
時間 | 交易T1                     | 交易T2
-----|----------------------------|---------------------------
t1   | READ balance = 1000        |
t2   |                            | READ balance = 1000
t3   | balance = 1000 + 500 = 1500|
t4   |                            | balance = 1000 + 300 = 1300
t5   | WRITE balance = 1500       |
t6   |                            | WRITE balance = 1300 ← 覆蓋！
```
**結果**：T1 的 +500 不見了！這叫做 **Lost Update (更新遺失)**。

**其他常見問題**：
1. **Dirty Read (髒讀)**：讀到未 Commit 的資料
2. **Non-Repeatable Read (不可重複讀)**：同一筆資料，兩次讀到不同值
3. **Phantom Read (幻讀)**：查詢結果的「筆數」前後不一致

**學習任務**：
1. 畫出三種問題的時間序列圖（模仿上面的表格）
2. 思考：如果沒有並行控制，電商購物會出什麼問題？

---

### Day 8-10: 鎖定機制 (Locking)

**核心概念**：用「鎖」來協調多個交易的存取順序。

#### **鎖的類型**

1. **Shared Lock (S-Lock, 共享鎖)**
   - 用途：讀取資料時加鎖
   - 規則：多個交易可以「同時」持有 S-Lock
   - 比喻：圖書館的書，可以多人同時閱讀

2. **Exclusive Lock (X-Lock, 排他鎖)**
   - 用途：寫入資料時加鎖
   - 規則：只有一個交易可以持有 X-Lock，且期間不能有其他鎖
   - 比喻：廁所，一次只能一個人用

#### **鎖的相容性矩陣**
```
        | S-Lock | X-Lock
--------|--------|--------
S-Lock  |   ✓    |   ✗
X-Lock  |   ✗    |   ✗
```

#### **Two-Phase Locking (2PL) 協定**
- **Phase 1 (Growing)**：只能加鎖，不能釋放鎖
- **Phase 2 (Shrinking)**：只能釋放鎖，不能加鎖
- **保證**：遵守 2PL 的交易排程 (Schedule) 是「可序列化 (Serializable)」的

**學習任務**：
1. 畫出一個 2PL 的時間序列圖
2. 找出一個「違反 2PL」的例子，並說明為什麼不安全

---

### Day 11-12: 死結 (Deadlock)

**什麼是死結？**
兩個交易互相等待對方釋放鎖，形成循環等待。

**經典場景**：
```
時間 | T1                  | T2
-----|---------------------|---------------------
t1   | LOCK X on A         |
t2   |                     | LOCK X on B
t3   | 等待 B 的鎖...      |
t4   |                     | 等待 A 的鎖... ← 卡住！
```

**死結的四個必要條件**（破壞任一條就能避免）：
1. **Mutual Exclusion (互斥)**：資源不能共享
2. **Hold and Wait (持有並等待)**：持有鎖的同時等待新鎖
3. **No Preemption (不可搶奪)**：不能強制釋放別人的鎖
4. **Circular Wait (循環等待)**：T1→T2→T1 的等待鏈

**死結處理策略**：
1. **預防 (Prevention)**：事先排序資源，統一加鎖順序
2. **偵測與恢復 (Detection & Recovery)**：用 Wait-For Graph 偵測，犧牲一個交易

**學習任務**：
1. 畫出一個死結的 Wait-For Graph
2. 設計一個「預防死結」的加鎖策略

---

## 第三週：恢復機制 (Recovery)

### Day 13-15: 為什麼需要恢復？

**失敗類型**：
1. **Transaction Failure**：交易執行中發生錯誤 (Rollback)
2. **System Crash**：停電、系統當機
3. **Disk Failure**：硬碟損壞（最嚴重）

**核心工具**：Log (日誌)

---

### Day 16-18: 日誌與檢查點

#### **Write-Ahead Logging (WAL)**
- **規則**：先寫 Log，再寫資料
- **Log 內容**：
  ```
  <T1, START>
  <T1, A, old=1000, new=1500>
  <T1, COMMIT>
  ```

#### **Checkpoint (檢查點)**
- **目的**：減少恢復時需要掃描的 Log 數量
- **動作**：
  1. 暫停新交易
  2. 強制寫入所有已 Commit 的變更到磁碟
  3. 記錄 `<CHECKPOINT>`

**ARIES 演算法** (考試常考)：
- **Analysis Pass**：確認哪些交易需要 Redo/Undo
- **Redo Pass**：重做已 Commit 但未寫入磁碟的交易
- **Undo Pass**：撤銷未 Commit 的交易

**學習任務**：
1. 模擬一次系統當機，畫出 Recovery 的步驟
2. 解釋為什麼 Checkpoint 可以加速恢復

---

## 第四週：實戰演練

### Day 19-21: 歷屆考題練習

我會從 `processed/db/` 中挑選 112-114 年的交易管理考題，幫你做成練習集。

**練習方向**：
1. **ACID 應用題**：判斷某個排程是否滿足 ACID
2. **2PL 畫圖題**：給定交易序列，畫出加鎖時間線
3. **死結偵測題**：畫出 Wait-For Graph
4. **Recovery 計算題**：給定 Log，判斷系統恢復後的狀態

---

### Day 22-24: 動手實作

**實作項目 1**：模擬死結
```python
# 使用兩個 Thread 模擬死結情境
```

**實作項目 2**：寫一個簡單的 Log Parser
- 讀取 WAL Log
- 判斷哪些交易需要 Redo/Undo

---

## 📖 推薦資源

1. **教科書**：
   - 《Database System Concepts》by Silberschatz (Ch. 14-16)
   - 《Fundamentals of Database Systems》by Elmasri (Ch. 20-21)

2. **線上資源**：
   - CMU 15-445 Database Systems (YouTube)
   - 台大資料庫系統課程

3. **練習題庫**：
   - 我會從你的 74 份考題中篩選交易管理相關題目

---

## ✅ 學習檢核表

完成每個項目後打勾：

**第一週**
- [ ] 能解釋什麼是交易
- [ ] 能背出並解釋 ACID 四個特性
- [ ] 能舉出違反 ACID 的實例

**第二週**
- [ ] 理解 S-Lock 與 X-Lock 的差異
- [ ] 能畫出 2PL 的時間序列圖
- [ ] 能辨識死結並畫出 Wait-For Graph

**第三週**
- [ ] 理解 WAL 的運作原理
- [ ] 能手動執行 ARIES 演算法的三個 Pass
- [ ] 能計算 Checkpoint 後的恢復時間

**第四週**
- [ ] 完成至少 5 題歷屆考題
- [ ] 能在 DBeaver 中展示並行控制的問題

---

## 下一步

你可以：
1. **開始學習**：按照這份計畫，每天投入 1-2 小時
2. **要實戰題目**：告訴我，我可以從 74 份考題中篩選交易管理題目
3. **客製化調整**：如果某個主題特別難，我可以為你拆解得更細

需要我幫你做什麼嗎？例如：
- 生成「死結模擬」的 Python 程式？
- 篩選 112-114 年的交易管理考題？
- 解釋某個特定概念（例如：Phantom Read 和 Non-Repeatable Read 的差異）？
