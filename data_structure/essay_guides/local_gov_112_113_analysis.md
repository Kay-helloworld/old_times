# 地方政府特考三等 資料結構 完整題目解析 (112-113年)

這份文件針對**地方政府特考三等 (112-113年)** 的資料結構考題提供詳盡的申論題答題架構，涵蓋**樹狀結構 (AVL, Heap, 2-4 Tree, RB Tree)**、**圖形演算法 (BFS, DFS)**、**排序演算法**與**遞迴分析**等核心考點。

---

## 2. 📊 題目總覽

### 2.1 題目統計表
| 統計項目 | 數量 |
|---------|------|
| **分析考卷總數** | **2 份** (112年, 113年) |
| **總題數** | **10 題** |
| **涵蓋主題** | 樹狀結構, 圖形, 排序, 遞迴, 鏈結串列 |
| **難度評估** | ⭐⭐⭐⭐ (偏重實作與觀念整合) |

### 2.2 題型分類表
| 題型 | 占比 | 代表題目 | 難度 |
|------|------|---------|------|
| **樹狀結構 (Trees)** | 40% | AVL/Heap/2-4 Tree 建置, 紅黑樹轉換 | ⭐⭐⭐⭐ |
| **圖形演算法 (Graphs)** | 20% | BFS/DFS 追蹤, 相鄰矩陣轉圖 | ⭐⭐⭐ |
| **演算法分析 (Analysis)** | 20% | 遞迴複雜度分析, 排序演算法比較 | ⭐⭐⭐⭐ |
| **基礎資料結構** | 20% | Linked List 搜尋, Priority Queue ADT | ⭐⭐⭐ |

**難度星級說明**：
- ⭐⭐⭐ = 基礎必考
- ⭐⭐⭐⭐ = 進階重要
- ⭐⭐⭐⭐⭐ = 新興熱門

---

## 3. 🎯 申論題答題黃金架構

```markdown
### 通用架構 (適用於資料結構題目)

第一部分：定義與背景 (15%)
├─ 定義關鍵術語 (如：AVL Tree 的平衡條件)
├─ 說明資料結構的特性 (如：Min Heap 的父子關係)
└─ 闡述主要目的 (如：為何需要 2-4 Tree)

第二部分：核心內容 (50%)
├─ 詳細演算過程 (Step-by-step trace)
├─ 繪製圖表 (Tree/Graph 的變化過程)
├─ 虛擬碼或程式碼 (如要求)
└─ 關鍵步驟說明

第三部分：比較分析 (20%)
├─ 時間/空間複雜度分析
├─ 與其他結構比較 (如：AVL vs RB Tree)
└─ 適用情境說明

第四部分：實務應用與延伸 (15%)
├─ 實際應用場景 (如：OS 排程, 資料庫索引)
├─ 實作注意事項
└─ 延伸相關概念
```

---

## 4. 📚 【核心知識】完全解析

### 一、高等樹狀結構比較 (AVL, Heap, 2-4 Tree, RB Tree)

| 特性 | AVL Tree | Min/Max Heap | 2-4 Tree | Red-Black Tree |
|------|----------|--------------|----------|----------------|
| **結構** | Binary Search Tree | Complete Binary Tree | Multi-way Search Tree | Binary Search Tree |
| **平衡條件** | 左右子樹高度差 $\le 1$ | 無 (僅需滿足 Heap Order) | 節點資料數 1~3, 所有葉節點同深 | 路徑黑節點數相同, 紅不接紅 |
| **搜尋複雜度** | $O(\log n)$ | $O(n)$ (非搜尋樹) | $O(\log n)$ | $O(\log n)$ |
| **插入/刪除** | $O(\log n)$ (需旋轉) | $O(\log n)$ (Heapify) | $O(\log n)$ (Split/Merge) | $O(\log n)$ (變色/旋轉) |
| **主要用途** | 頻繁搜尋的資料庫 | 優先權佇列 (Priority Queue) | 資料庫索引 (B-Tree 變體) | 系統程式 (如 Linux 排程) |

### 二、圖形走訪 (BFS vs DFS)

| 特性 | BFS (廣度優先) | DFS (深度優先) |
|------|----------------|----------------|
| **資料結構** | Queue (FIFO) | Stack (LIFO) |
| **走訪順序** | 層層推進 (Level-order) | 一條路走到底 (Backtracking) |
| **路徑特性** | 保證最短路徑 (無加權圖) | 不保證最短路徑 |
| **應用** | 最短路徑, 網路廣播 | 迷宮, 拓樸排序, 連通單元 |

### 三、排序演算法複雜度總整理

| 演算法 | Best Case | Average Case | Worst Case | Stable | In-Place |
|--------|-----------|--------------|------------|--------|----------|
| **Bubble Sort** | $O(n)$ | $O(n^2)$ | $O(n^2)$ | Yes | Yes |
| **Insertion Sort** | $O(n)$ | $O(n^2)$ | $O(n^2)$ | Yes | Yes |
| **Selection Sort** | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | No | Yes |
| **Quick Sort** | $O(n \log n)$ | $O(n \log n)$ | $O(n^2)$ | No | Yes (Stack space $O(\log n)$) |
| **Merge Sort** | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | Yes | No ($O(n)$) |
| **Heap Sort** | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | No | Yes |

---

## 5. 📝 完整題目解析 (112年)

### 題目 1：Linked List 線性搜尋 (迴圈與遞迴)

#### 📖 原題 (112年地方特考三等)

> **題目**：請以 C, C++, C#, Java 或 Python 撰寫 2 個方法，一個以迴圈方式，一個以遞迴方式，對存在 singular linked list 的資料進行 linearly search。假設 Node 的結構如下：（12 分）
> ```cpp
> struct Node {
>     int data;
>     Node *next;
> };
> ```

#### 🎯 答題架構分析

1.  **定義 Node 結構**：雖然題目已給，但寫程式前應再次確認或宣告。
2.  **迴圈版本 (Iterative)**：使用 `while` 或 `for` 走訪鏈結串列。
3.  **遞迴版本 (Recursive)**：定義 Base Case (空或找到) 與 Recursive Step (往 next 找)。
4.  **比較與說明**：簡述兩者差異 (時間/空間複雜度)。

#### 📊 評分建議 (預估配分 12 分)

**第一部分：迴圈版本 (6 分)**
- 正確宣告函式與參數 (2 分)
- 正確使用迴圈走訪 (2 分)
- 正確處理邊界條件 (找不到/空串列) (2 分)

**第二部分：遞迴版本 (6 分)**
- 正確宣告函式與參數 (2 分)
- 正確設定終止條件 (Base Case) (2 分)
- 正確遞迴呼叫 (2 分)

#### ✍️ 標準答案示範

**解答**：

本題使用 C++ 語言實作。

**一、Node 結構定義**

```cpp
struct Node {
    int data;
    Node *next;
};
```

**二、迴圈方式 (Iterative Approach)**

```cpp
// 搜尋 target，若找到回傳該 Node 指標，否則回傳 NULL
Node* searchIterative(Node* head, int target) {
    Node* current = head;
    while (current != NULL) {
        if (current->data == target) {
            return current; // 找到目標
        }
        current = current->next; // 移動到下一個節點
    }
    return NULL; // 走訪完畢未找到
}
```

**三、遞迴方式 (Recursive Approach)**

```cpp
// 搜尋 target，若找到回傳該 Node 指標，否則回傳 NULL
Node* searchRecursive(Node* head, int target) {
    // Base Case 1: 串列為空，或已走訪完畢
    if (head == NULL) {
        return NULL;
    }
    // Base Case 2: 找到目標
    if (head->data == target) {
        return head;
    }
    // Recursive Step: 往剩下的一部份繼續找
    return searchRecursive(head->next, target);
}
```

#### 💡 補充說明

**複雜度比較**：
- **時間複雜度**：兩者皆為 $O(n)$，其中 $n$ 為節點數。
- **空間複雜度**：
  - 迴圈版本：$O(1)$，僅需額外指標變數。
  - 遞迴版本：$O(n)$，最差情況下 (尾端或找不到) 需 $n$ 層 Stack Frame。因此實務上 Linked List 搜尋較少用遞迴，避免 Stack Overflow。

---

### 題目 2：高等樹狀結構建置 (AVL, Heap, 2-4 Tree)

#### 📖 原題 (112年地方特考三等)

> **題目**：請為數列 0, 10, 30, 20, 50, 80, 40, 90, 70, 60 建立 AVL tree, Min/Max heap, 2-4 tree，並依它們的性質以 yes or no 完成下表。註：所建立的 tree or heap 請以圖示，如果是 Searching Tree，請以左小右大的方式建立。（24 分）
> (表格包含：Balance Searching Tree, AVL tree, Min heap, Max heap, 2-4 tree)

#### 🎯 答題架構分析

1.  **建置 AVL Tree**：逐步插入，檢查平衡因子，執行旋轉 (LL, RR, LR, RL)。
2.  **建置 Min/Max Heap**：逐步插入並 Up-Heap (或一次建置 Down-Heap)，題目通常指逐步建立。
3.  **建置 2-4 Tree**：逐步插入，節點滿 (4 keys) 時分裂 (Split) 並上提。
4.  **填寫性質表格**：判斷各樹種是否為 Balance Searching Tree 等性質。

#### 📊 評分建議 (預估配分 24 分)

- **AVL Tree 建置正確** (6 分)：關鍵在 30, 50, 80, 60 等插入時的旋轉。
- **Min/Max Heap 建置正確** (6 分)：結構與順序正確。
- **2-4 Tree 建置正確** (6 分)：分裂過程正確。
- **表格填寫正確** (6 分)：對各樹種性質的理解。

#### ✍️ 標準答案示範

**解答**：

**一、AVL Tree 建置過程**

數列：0, 10, 30, 20, 50, 80, 40, 90, 70, 60

1. 插入 0, 10, 30 → RR 旋轉 (10 為根, 0 左, 30 右)
2. 插入 20, 50
3. 插入 80 → 30-50-80 RR 旋轉
4. ... (省略中間詳細步驟，直接畫出最終結果)

**最終 AVL Tree 圖示**：
```
        40
      /    \
    20      70
   /  \    /  \
  10  30  60  80
 /       /      \
0       50      90
```
*(註：考試時需畫出節點與連線)*

**二、Min Heap 建置** (逐步插入)

**最終 Min Heap 圖示**：
```
        0
      /   \
    10     40
   /  \   /  \
  20  50 80  90
 / \  /
70 60 30
```

**三、Max Heap 建置** (逐步插入)

**最終 Max Heap 圖示**：
```
        90
      /    \
    80      60
   /  \    /  \
  70  50  30  40
 / \  /
0 10 20
```

**四、2-4 Tree 建置**

**最終 2-4 Tree 圖示**：
```
      [ 40 ]
     /      \
[10, 20, 30] [60, 80]
 /  |   |  \  /   |   \
0  10  20  30 50 70 90
(註：實際 2-4 Tree 葉節點包含資料，或指向資料。上圖為簡化示意，根節點 40，左子節點含 10,20,30，右子節點含 60,80)
```
*更正：2-4 Tree 插入 60 後的分裂狀況需精確推導。*
最終結構可能為：
Root: [20, 40, 80]
Children: [0, 10], [30], [50, 60, 70], [90]
*(需依據具體分裂策略，通常是 Pre-emptive split 或 Post-split)*

**五、性質表格填寫**

| 性質 | Balance Searching Tree | AVL tree | Min heap | Max heap | 2-4 tree |
|------|------------------------|----------|----------|----------|----------|
| **Is Balance Searching Tree?** | - | **Yes** | **No** | **No** | **Yes** |

*(註：Heap 是 Complete Binary Tree 但不是 Searching Tree (BST)。AVL 和 2-4 Tree 都是平衡搜尋樹)*

#### 💡 補充說明

- **AVL Tree**：嚴格平衡，適合搜尋多、插入刪除少的場景。
- **2-4 Tree**：是 B-Tree 的一種 (Order 4)，對應到 Red-Black Tree。
- **Heap**：適合實作 Priority Queue，找最大/最小值 $O(1)$。

---

### 題目 3：Huffman Coding 解碼

#### 📖 原題 (112年地方特考三等)

> **題目**：請以如下的 Huffman Tree 所做的數字編碼，解讀 01010111110100100011 編碼對應的數字。（10 分）
> (題目附圖為 Huffman Tree，需依圖解碼)

#### 🎯 答題架構分析

1.  **觀察 Huffman Tree**：題目未提供圖，但通常是左 0 右 1 或左 1 右 0。需先假設或由題目圖判斷。假設左=0, 右=1 (常見慣例)。
2.  **解碼過程**：從根節點開始，讀取位元，0 往左，1 往右，直到葉節點，輸出該數字，再回到根節點。
3.  **輸出結果**：寫出解碼後的數字序列。

#### 📊 評分建議 (預估配分 10 分)

- **解碼正確性** (10 分)：完全正確得滿分，錯一個數字扣部分分。

#### ✍️ 標準答案示範

**解答**：

*(由於無法看到原題圖片，以下為解題邏輯示範)*

假設 Huffman Tree 結構如下 (示意)：
- 0: 往左子樹
- 1: 往右子樹
- 葉節點對應數字 (例如 A=0, B=10, C=110...)

**解碼步驟**：
1. 讀取 `0` → 走左 → ... → 到達葉節點 X，輸出 X。
2. 重置回根節點。
3. 讀取 `1` → 走右 ...
4. 重複直到字串結束。

**假設結果**：
若解碼出數字序列為 `3, 5, 2, ...`，則答案寫：
**解碼結果：352...**

#### 💡 補充說明

- **Prefix Property**：Huffman Code 滿足前綴性質，即沒有任何一個編碼是另一個編碼的前綴，保證解碼唯一性。
- **建置方法**：使用 Min Heap 取頻率最小的兩個節點合併，直到剩下一棵樹。

---

### 題目 4：圖形 BFS 與 DFS 追蹤

#### 📖 原題 (112年地方特考三等)

> **題目**：針對如下的有向圖... 依 BFS (配合 queue) 與 DFS (配合 stack) 演算法... 多個節點可以走訪時，以連線上 cost 較低者優先... 填寫表格。(24 分)

#### 🎯 答題架構分析

1.  **理解規則**：
    - BFS 用 Queue，DFS 用 Stack。
    - **優先權**：Cost 較低者優先 (非 ID 大小)。
    - **ProcessSet**：紀錄已處理/拜訪過的節點，避免重複。
2.  **逐步追蹤 (Trace)**：
    - 畫出 Queue/Stack 的變化。
    - 畫出 ProcessSet 的變化。
    - 紀錄 Print Node 的順序。
3.  **填表**：依題目要求的格式填入每一步驟的狀態。

#### 📊 評分建議 (預估配分 24 分)

- **BFS 過程正確** (12 分)：Queue 的進出順序、Cost 判斷正確。
- **DFS 過程正確** (12 分)：Stack 的進出順序、Backtracking 正確。

#### ✍️ 標準答案示範

**解答**：

*(需依據原圖 Cost 進行推導，以下為邏輯示範)*

**一、BFS 演算法 (使用 Queue)**

| Loop | Print Node | Queue (Front -> Rear) | ProcessSet |
|------|------------|-----------------------|------------|
| 1    | S          | [A, B] (假設 Cost S->A < S->B) | {S, A, B} |
| 2    | A          | [B, C, D] (A 的鄰居依 Cost 入列) | {S, A, B, C, D} |
| ...  | ...        | ...                   | ...        |

**二、DFS 演算法 (使用 Stack)**

| Loop | Print Node | Stack (Top -> Bottom) | ProcessSet |
|------|------------|-----------------------|------------|
| 1    | S          | [B, A] (假設 Cost S->A < S->B，A 在 Top 優先處理?) | {S, A, B} |
|      |            | *(註：DFS 實作細節需注意，通常是將鄰居反向 Push 或 Pop 時才決定順序。題目說 "enqueue/push all one step neighbors... according to cost"，若 Stack 是 LIFO，要先處理 Cost 小的，則 Cost 大的先 Push，Cost 小的後 Push)* | |
| 2    | A          | [B, D, C] (A 的鄰居 C, D，假設 Cost A->C < A->D，則 D 先 Push, C 後 Push) | {S, A, B, C, D} |
| ...  | ...        | ...                   | ...        |

**關鍵點**：
- **BFS**：Cost 小的先 Enqueue。
- **DFS**：Cost 小的要先 Pop，所以 Cost **大**的要先 Push (若一次 Push 所有鄰居)。

#### 💡 補充說明

- **BFS** 適用於找無權重圖的最短路徑。
- **DFS** 適用於窮舉路徑或偵測 Cycle。
- 此題結合 Cost 優先權，類似 Best-First Search 的變體，但 BFS 仍是層級式，只是同層級有順序。

---

### 題目 5：排序演算法比較表

#### 📖 原題 (112年地方特考三等)

> **題目**：請完成下列表格有關排序演算法的 time complexity... 是否為 In Space... 是否為 Stable... 及範例數列 50, 46, 37, 28, 19 進行降冪排列時所需的比較次數。（30 分）
> (Bubble, Insertion, Merge, Quick, Radix, Selection)

#### 🎯 答題架構分析

1.  **複雜度填寫**：填寫 Best/Worst Case。
2.  **性質填寫**：In-Space (In-Place), Stable。
3.  **比較次數計算**：針對 `50, 46, 37, 28, 19` 轉為 **降冪 (由大到小)**。
    - 注意原數列已經是降冪 (`50 > 46 > 37 > 28 > 19`)。
    - 題目要求 **降冪排列**，即目標是 `50, 46, 37, 28, 19`。
    - 原數列 **已經排序完成**。
    - 需計算各演算法在 "已排序" 情況下的比較次數。

#### 📊 評分建議 (預估配分 30 分)

- **複雜度與性質** (20 分)：每格約 1 分。
- **比較次數** (10 分)：需精確計算。

#### ✍️ 標準答案示範

**解答**：

數列：`50, 46, 37, 28, 19`，目標：**降冪** (由大到小)。
現況：**已排序 (Best Case)**。

| 排序演算法 | Best Time | Worst Time | In-Space | Stable | 比較次數 (50,46,37,28,19 降冪) |
|------------|-----------|------------|----------|--------|------------------------------|
| **Bubble** | $O(n)$ | $O(n^2)$ | Yes | Yes | **4** (一輪掃描無交換即停止) |
| **Insertion**| $O(n)$ | $O(n^2)$ | Yes | Yes | **4** (每個元素只比一次) |
| **Merge** | $O(n \log n)$| $O(n \log n)$| No | Yes | **約 12** (遞迴分割合併，固定比較) |
| **Quick** | $O(n \log n)$| $O(n^2)$ | Yes | No | **10** (若 Pivot 取第一個，已排序為 Worst Case，比較 4+3+2+1) |
| **Radix** | $O(d \cdot n)$| $O(d \cdot n)$| No | Yes | **0** (不進行比較，由位數決定) |
| **Selection**| $O(n^2)$ | $O(n^2)$ | Yes | No | **10** (無論是否排序，比較 4+3+2+1) |

**詳細說明**：
1. **Bubble Sort** (優化版)：第一輪比較 4 次 (50vs46, 46vs37...)，無交換，Flag 未立，結束。
2. **Insertion Sort**：第二個元素開始，每個往前比 1 次發現已定位，共 4 次。
3. **Quick Sort**：題目指定 "第一個當 Pivot"。
   - Pivot 50: 比 46, 37, 28, 19 (4次) -> 全部在右邊(或左邊視實作)。
   - Pivot 46: 比 37, 28, 19 (3次)。
   - ... 4+3+2+1 = 10 次 (Worst Case)。
4. **Selection Sort**：第一輪找最大比 4 次，第二輪比 3 次... 固定 $n(n-1)/2 = 10$ 次。

#### 💡 補充說明

- **Quick Sort Worst Case**：當 Pivot 選到最大或最小值(如已排序陣列選第一個)時發生。
- **Radix Sort**：非比較排序，故比較次數為 0 或不適用。

---

## 6. 📝 完整題目解析 (113年)

### 題目 1：遞迴演算法分析 Q(n)

#### 📖 原題 (113年地方特考三等)

> **題目**：考慮下面以虛擬碼表示的遞迴演算法：
> ```
> Algorithm Q(n)
> if n=1 return 1
> else return Q(n-1) + 2*n - 1
> ```
> (1) 列出 Q(n) 遞迴關係式，並說明計算的是什麼？(5分)
> (2) 用遞迴函式表示乘法運算次數，並用 Big-O 表示。(5分)
> (3) 以遞迴函式表示執行時間 T(n) 並說明時間複雜度。(10分)

#### 🎯 答題架構分析

1.  **遞迴關係式**：直接由程式碼轉譯。
2.  **功能分析**：展開遞迴式，觀察數列規律 (1, 4, 9...)。
3.  **乘法次數**：計算 `2*n` 的次數。
4.  **時間複雜度**：計算基本運算的次數。

#### 📊 評分建議 (預估配分 20 分)

- **關係式與功能** (5 分)：正確寫出 $Q(n)$ 並識別出 $n^2$。
- **乘法次數** (5 分)：正確寫出 $M(n)$ 與 $O(n)$。
- **時間複雜度** (10 分)：正確寫出 $T(n)$ 與 $O(n)$。

#### ✍️ 標準答案示範

**解答**：

**(1) 遞迴關係式與功能**
- **遞迴關係式**：
  $$Q(n) = \begin{cases} 1 & \text{if } n=1 \\ Q(n-1) + 2n - 1 & \text{if } n > 1 \end{cases}$$
- **功能說明**：
  計算 $Q(n) = 1 + \sum_{i=2}^n (2i - 1) = \sum_{i=1}^n (2i - 1)$。
  這是一個奇數數列的和：$1, 3, 5, \dots, 2n-1$。
  奇數和公式為 $n^2$。
  驗證：$Q(1)=1=1^2$, $Q(2)=1+3=4=2^2$, $Q(3)=4+5=9=3^2$。
  故此演算法計算 **$n$ 的平方 ($n^2$)**。

**(2) 乘法運算次數**
- **遞迴函式**：
  設 $M(n)$ 為乘法次數。
  $$M(n) = \begin{cases} 0 & \text{if } n=1 \\ M(n-1) + 1 & \text{if } n > 1 \end{cases}$$
  (註：每次遞迴執行 `2*n` 一次乘法)
- **Big-O 表示**：
  $M(n) = n - 1$，故為 **$O(n)$**。

**(3) 執行時間 T(n)**
- **遞迴函式**：
  設 $T(n)$ 為執行時間 (步驟數)。
  $$T(n) = \begin{cases} c_1 & \text{if } n=1 \\ T(n-1) + c_2 & \text{if } n > 1 \end{cases}$$
  (其中 $c_1, c_2$ 為常數)
- **時間複雜度**：
  展開後 $T(n) = T(n-1) + c_2 = T(n-2) + 2c_2 = \dots = T(1) + (n-1)c_2$。
  $T(n) = c_1 + (n-1)c_2$。
  故時間複雜度為 **$O(n)$**。

---

### 題目 2：運算式二元樹 (Expression Tree)

#### 📖 原題 (113年地方特考三等)

> **題目**：
> (1) 將算術運算式 `( ( ( 5 + 1 ) * 3 - (7 + 2 ) ) / ( ( ( 2 * 8 ) + 5 ) / 7 ) )` 以算術運算樹表示。(5分)
> (2) 判斷是否為滿二元樹 (Full Binary Tree)。(5分)
> (3) 轉為前序表示式 (Preorder)。(5分)
> (4) 說明如何計算值。(10分)

#### 🎯 答題架構分析

1.  **建樹**：依括號優先順序，由內而外，或由運算子優先權建樹。Root 為最外層運算子 `/`。
2.  **Full Binary Tree 定義**：每個節點有 0 或 2 個子節點。
3.  **Preorder**：根-左-右 走訪。
4.  **計算過程**：Postorder 走訪 (左右根) 計算子樹值再運算。

#### ✍️ 標準答案示範

**解答**：

**(1) 算術運算樹**
*(文字示意)*
```
          /
      /       \
    -           /
  /   \       /   \
 *     +     +     7
/ \   / \   / \
+  3  7  2  *  5
/ \         / \
5 1         2 8
```
*(考試請畫出完整樹狀圖)*

**(2) 是否為滿二元樹 (Full Binary Tree)**
- **定義**：Full Binary Tree (或 Proper Binary Tree) 指每個節點的子節點數皆為 0 或 2。
- **判斷**：此運算樹的所有內部節點皆為運算子 (二元運算子)，皆有左右兩個運算元 (子節點)。所有葉節點皆為運算元 (數字)。
- **答案**：**是 (Yes)**。

**(3) 前序表示式 (Preorder)**
- **走訪順序**：根 → 左 → 右
- **結果**：`/ - * + 5 1 3 + 7 2 / + * 2 8 5 7`

**(4) 計算過程**
採用 **後序走訪 (Postorder Traversal)** 的概念，由下而上計算：
1. 計算左子樹：
   - `5+1=6`
   - `6*3=18`
   - `7+2=9`
   - `18-9=9` (左子樹結果)
2. 計算右子樹：
   - `2*8=16`
   - `16+5=21`
   - `21/7=3` (右子樹結果)
3. 計算根節點：
   - `9 / 3 = 3`
- **最終結果**：**3**

---

### 題目 3：優先佇列與 Heap 搜尋

#### 📖 原題 (113年地方特考三等)

> **題目**：
> (1) 說明優先佇列 (Priority Queue) 的 ADT 定義。(10分)
> (2) 給定 Min Heap H 與鍵值 k，找出所有鍵值 <= k 的資料。描述一個有效方法，時間與找出數量成線性比例。(5分)

#### ✍️ 標準答案示範

**解答**：

**(1) Priority Queue ADT**
Priority Queue 是一種抽象資料型態，管理一組具有優先權 (Key) 的元素。
**主要操作**：
1. `insert(item, priority)`: 將帶有優先權的元素加入佇列。
2. `deleteMin()` (或 `deleteMax()`): 移除並回傳優先權最高 (Key 最小或最大) 的元素。
3. `min()` (或 `max()`): 查看優先權最高的元素 (不移除)。
4. `isEmpty()`: 檢查佇列是否為空。
5. `size()`: 回傳元素個數。

**(2) 找出 <= k 的元素 (線性時間演算法)**
**演算法描述**：
使用遞迴 (或 Stack/Queue) 進行受限的走訪 (Pruned Traversal)。
1. 從根節點 (Root) 開始檢查。
2. 若目前節點 `node.key > k`：
   - 根據 Min Heap 性質，其所有子孫節點皆大於 `node.key`，故必定大於 `k`。
   - **停止**該路徑的搜尋 (Pruning)。
3. 若目前節點 `node.key <= k`：
   - **輸出**該節點。
   - 對其左子節點與右子節點 **遞迴執行** 此檢查。

**時間複雜度分析**：
- 假設輸出 $m$ 個元素。
- 演算法僅會拜訪 "輸出的節點" 以及 "其直接子節點 (可能不輸出)"。
- 拜訪的節點總數不超過 $2m + 1$ (或 $3m$ 等級)。
- 故時間複雜度為 **$O(m)$**，與輸出數量成線性比例。

---

### 題目 4：紅黑樹與 (2,4)-Tree

#### 📖 原題 (113年地方特考三等)

> **題目**：
> (1) 說明紅黑樹與 (2,4)-Tree 的定義。(10分)
> (2) 將給定的紅黑樹轉換為 (2,4)-Tree，並說明是否唯一。(10分)
> (3) 說明為何 n 個節點的紅黑樹高度是 O(log n)。(5分)

#### ✍️ 標準答案示範

**解答**：

**(1) 定義**
- **紅黑樹 (Red-Black Tree)**：
  一種二元搜尋樹，滿足：
  1. 節點為紅色或黑色。
  2. 根節點為黑色。
  3. 葉節點 (NIL) 為黑色。
  4. 紅色節點的子節點必為黑色 (不連續紅)。
  5. 任一節點到其葉子孫的所有路徑包含相同數量的黑色節點 (Black Height)。
- **(2,4)-Tree**：
  一種 Multi-way Search Tree (B-Tree 的特例 Order 4)，滿足：
  1. 每個內部節點有 2, 3 或 4 個子節點 (即 1, 2 或 3 個 Keys)。
  2. 所有葉節點位於同一深度 (Perfectly Balanced)。

**(2) 轉換與唯一性**
- **轉換方法**：
  將紅黑樹中的 **紅色節點** 與其 **黑色父節點** 合併，形成一個 (2,4)-Tree 的節點 (Supernode)。
  - 黑：獨立形成節點 (2-node)。
  - 黑-紅 (左或右)：形成 3-node。
  - 黑-紅-紅 (左右)：形成 4-node。
- **唯一性**：
  **是**。給定一棵合法的紅黑樹，其對應的 (2,4)-Tree 是唯一的。因為紅色節點必須依附於父節點，結構關係是固定的。
  (反之，一個 (2,4)-Tree 轉紅黑樹則不唯一，因 3-node 有兩種紅黑表示法)。

**(3) 高度證明 O(log n)**
- 紅黑樹對應到 (2,4)-Tree。
- (2,4)-Tree 是平衡樹，高度 $h \le \log_2 n$。
- 紅黑樹的高度 $H_{RB}$ 最多是 (2,4)-Tree 高度的 2 倍 (當路徑上紅黑交替時)。
- 即 $H_{RB} \le 2 \times H_{2-4} \le 2 \log_2 n$。
- 故高度為 **$O(\log n)$**。

---

### 題目 5：圖形相鄰矩陣與 BFS

#### 📖 原題 (113年地方特考三等)

> **題目**：給定相鄰矩陣 M...
> (1) 畫出無向圖 G。(10分)
> (2) 由節點 a 開始，字母順序優先，畫出 BFS Tree。(5分)

#### ✍️ 標準答案示範

**解答**：

**(1) 無向圖 G**
依矩陣還原邊集合：
- a: (a,b), (a,d), (a,e), (a,f)
- b: (b,a), (b,c), (b,e), (b,f)
- c: (c,b), (c,f), (c,g)
- d: (d,a), (d,g)
- e: (e,a), (e,b)
- f: (f,a), (f,b), (f,c), (f,g)
- g: (g,c), (g,d), (g,f)

**(2) BFS Tree (從 a 開始)**
**走訪過程** (Queue):
1. Start **a**. Q: [b, d, e, f] (依字母序). Tree Edges: (a,b), (a,d), (a,e), (a,f).
2. Visit **b**. Neighbors: a(v), c, e(v), f(v). Add c. Q: [d, e, f, c]. Tree Edge: (b,c).
3. Visit **d**. Neighbors: a(v), g. Add g. Q: [e, f, c, g]. Tree Edge: (d,g).
4. Visit **e**. Neighbors: a(v), b(v). No add.
5. Visit **f**. Neighbors: a, b, c(in Q), g(in Q). No add.
6. Visit **c**. Neighbors: b, f, g. All visited/in Q.
7. Visit **g**. Neighbors: c, d, f. All visited.

**BFS Tree 結構**：
- Root: a
- Level 1: b, d, e, f (children of a)
- Level 2: c (child of b), g (child of d)

```
      a
   / | | \
  b  d e  f
  |  |
  c  g
```

---

## 7. 💡 答題技巧總結

### 時間分配建議 (考試時間：2小時)

- **題目數量**：通常為 4-5 題。
- **每題平均時間**：約 24-30 分鐘。
- **建議分配**：
  - **審題與構思 (3-5分鐘)**：確認題目要求 (如：是否需畫圖、是否需寫程式、特定演算法限制)。
  - **核心作答 (15-20分鐘)**：
    - **演算法/程式題**：先寫虛擬碼或註解邏輯，再補完細節。
    - **計算/追蹤題**：務必畫出關鍵步驟的圖示 (如 Tree 的旋轉、Heap 的調整)。
  - **檢查與修飾 (3-5分鐘)**：檢查邊界條件、變數名稱一致性、複雜度分析是否遺漏。

### 分數取捨策略

**優先寫（高CP值）**：
- ✅ **圖表與視覺化**：Tree/Graph 的結構圖、演算法流程圖。閱卷老師能一眼看懂，得分效率高。
- ✅ **表格比較**：如 AVL vs RB Tree，BFS vs DFS。條理分明，展現觀念清晰。
- ✅ **關鍵字命中**：如 "O(log n)", "Balance Factor", "Complete Binary Tree" 等專有名詞。
- ✅ **虛擬碼 (Pseudocode)**：若題目未強制指定語言，寫虛擬碼通常比除錯完整的 C++/Java 更快且不易出錯。

**可捨棄（低CP值）**：
- ⚠️ **過度冗長的文字敘述**：避免寫作文，盡量用列點 (Bullet points)。
- ⚠️ **完美的程式語法**：除非題目強調 "Syntax Correct"，否則邏輯正確比少一個分號重要。
- ⚠️ **冷僻的數學證明**：除非題目要求證明 (如證明高度)，否則直接引用已知結論 (Theorem) 即可。

### 加分技巧

- 📊 **表格化**：差異比較一律用表格。
- 📈 **圖解過程**：不要只給答案，畫出 "Before -> Action -> After" 的變化。
- 📝 **註解**：程式碼旁邊加上簡單註解說明該行目的。
- 💡 **延伸思考**：在結論處補充該資料結構的實際應用 (如：OS 排程、資料庫索引)，展現廣度。

---

## 8. 📚 參考資源

### 經典教科書
- **Fundamentals of Data Structures in C++** (Horowitz, Sahni, Mehta) - 資料結構聖經，特別是圖形與樹狀結構的定義。
- **Introduction to Algorithms** (CLRS) - 演算法分析與複雜度證明的權威。

### 線上學習資源
- **VisualAlgo** (visualalgo.net) - 演算法視覺化工具，極適合複習 Tree 旋轉與 Graph 走訪過程。
- **GeeksforGeeks** - 查找特定資料結構的實作細節與變體。
- **LeetCode** - 練習 Linked List, Tree, Graph 的實作題 (如 112年第一題即為 LeetCode Easy/Medium 難度)。

### 實務工具
- **Graphviz** - 繪製 Graph/Tree 的工具，練習時可用來產生標準圖形。
