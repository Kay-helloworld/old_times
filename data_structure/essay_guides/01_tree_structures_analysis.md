# 資料結構完整題目解析 - 樹狀結構 (Tree Structures)

這份文件針對**樹狀結構 (Tree Structures)**相關題目提供詳盡的申論題答題架構，涵蓋 **AVL Tree**、**Heap**、**B-Tree/2-4 Tree**、**Huffman Tree**、**二元樹走訪** 等核心考點。

---

## 1. 📊 題目總覽

### 1.1 題目統計表

| 統計項目 | 數量 |
|---------|------|
| **分析考卷總數** | **10 份** (104-113年) |
| **樹狀結構相關題目** | **22 題** |
| **占比** | **35%** (所有題型中最高) |
| **重要性排名** | **No. 1** |

### 1.2 題型分類表

| 題型 | 占比 | 代表題目 | 難度 |
|------|------|---------|------|
| **平衡樹操作 (AVL, B-Tree)** | 30% | AVL 旋轉、B-Tree 插入/刪除 | ⭐⭐⭐⭐ |
| **堆積與優先佇列 (Heap)** | 25% | Min/Max Heap 操作、Interval Heap | ⭐⭐⭐ |
| **樹的走訪與應用** | 20% | 前/中/後序、Expression Tree | ⭐⭐⭐ |
| **Huffman 編碼** | 15% | 建構 Huffman Tree、計算壓縮率 | ⭐⭐⭐ |
| **樹的性質與證明** | 10% | m-ary Tree 高度推導、二元樹性質 | ⭐⭐⭐⭐⭐ |

**難度星級說明**：
- ⭐⭐⭐ = 基礎必考 (Heap, 走訪, Huffman)
- ⭐⭐⭐⭐ = 進階重要 (AVL, B-Tree 操作)
- ⭐⭐⭐⭐⭐ = 困難證明 (性質推導, 複雜演算法)

---

## 2. 📚 【核心知識】完全解析

### 一、常見平衡樹比較 (AVL vs B-Tree vs 2-4 Tree)

| 特性 | AVL Tree | B-Tree (Order m) | 2-4 Tree |
|------|----------|------------------|----------|
| **定義** | 高度平衡二元搜尋樹 | 多元搜尋樹 (Multi-way) | Order 4 的 B-Tree |
| **平衡條件** | 左右子樹高度差 $\le 1$ | 根節點至少 2 子節點，非根節點至少 $\lceil m/2 \rceil$ 子節點 | 節點可有 2, 3, 4 個子節點 |
| **高度** | $O(\log N)$ | $O(\log_m N)$ (底數大，高度低) | $O(\log N)$ |
| **應用** | 記憶體內搜尋 (In-memory) | 磁碟/資料庫索引 (Disk I/O) | B-Tree 的特例，常用於教學 |
| **調整方式** | 旋轉 (Rotation: LL, RR, LR, RL) | 分裂 (Split) 與 合併 (Merge) | 分裂與合併 |

### 二、Heap (堆積) 操作詳解

**Min Heap 定義**：
1. **Complete Binary Tree**：除了最後一層外，其餘層皆填滿，且最後一層節點靠左排列。
2. **Order Property**：父節點的值 $\le$ 子節點的值。

**關鍵操作**：
- **Insert(x)**：
  1. 將 x 放入最後一個位置 (維持 Complete)。
  2. **Bubble Up (Sift Up)**：若 x < 父節點，交換，直到滿足 Order Property。
- **DeleteMin()**：
  1. 移除根節點 (最小值)。
  2. 將最後一個節點移至根位置。
  3. **Bubble Down (Sift Down)**：與較小的子節點交換，直到滿足 Order Property。

### 三、Huffman Coding (霍夫曼編碼)

**目的**：資料壓縮 (Lossless Compression)。
**原理**：頻率高的字元用短編碼，頻率低的字元用長編碼 (Prefix Code)。
**建構步驟**：
1. 將所有字元視為單節點樹，依頻率排序放入 Priority Queue。
2. 取出頻率最小的兩個節點 $T1, T2$。
3. 建立新節點 $P$，權重為 $W(T1) + W(T2)$，將 $T1, T2$ 設為左右子樹。
4. 將 $P$ 放回 Queue。
5. 重複直到 Queue 只剩一棵樹。

---

## 3. 📝 完整題目解析 (113-104年)

### 題目 1：資料結構比較與繪圖 (AVL, Heap, 2-4 Tree)

#### 📖 原題 (113年地方特考三等)

> **題目**：假設我們有相同的資料集合（鍵值分別為 2, 4, 5, 7, 8, 9, 15, 20, 30, 40），請分別說明下列各資料結構中節點鍵值的關係，並畫出圖形以呈現資料儲存的結果。
> (一) AVL tree。（7 分）
> (二) Max heap。（6 分）
> (三) 2-4 tree。（7 分）

#### 🎯 答題架構分析

1. **AVL Tree**：需畫出平衡後的二元搜尋樹。注意插入過程中的旋轉 (Rotation)。
2. **Max Heap**：需畫出滿足 Max Heap 性質的完全二元樹。注意是由上而下、由左至右填入，並維持父節點 $\ge$ 子節點。
3. **2-4 Tree**：需畫出滿足 2-4 Tree 性質的樹。注意節點分裂 (Split) 的過程。

#### 📊 評分建議 (預估配分 20 分)

**第一小題 (AVL Tree) (7 分)**：
- 正確畫出最終的 AVL Tree 結構 (4分)
- 樹的高度平衡且符合 BST 性質 (3分)

**第二小題 (Max Heap) (6 分)**：
- 正確畫出 Max Heap 結構 (3分)
- 符合 Complete Binary Tree 且父節點 >= 子節點 (3分)

**第三小題 (2-4 Tree) (7 分)**：
- 正確畫出 2-4 Tree 結構 (4分)
- 節點內鍵值排序正確且符合子節點數量限制 (3分)

**答題提示**：
- ✅ 繪圖要清晰，節點與連線分明。
- ✅ 2-4 Tree 的節點可以畫成矩形，包含 1~3 個鍵值。
- ⚠️ Max Heap 不是唯一的，但通常依序插入即可。AVL Tree 插入順序不同結果不同，題目未指定順序通常假設「依鍵值大小順序」或「依題目給定順序」。此題給定集合順序為由小到大，若依此順序插入 AVL 會頻繁旋轉。

#### ✍️ 標準答案示範

**解答**：

**一、AVL Tree**

AVL Tree 為高度平衡二元搜尋樹，任一節點之左右子樹高度差絕對值不超過 1。
假設依題目給定順序 (2, 4, 5, ..., 40) 插入：

```text
        8
      /   \
     4     20
    / \   /  \
   2   5 15   30
        \    /  \
         7  9    40
```
*(註：依序插入會觸發多次旋轉，最終結果可能如上，根節點為中位數附近)*

**二、Max Heap**

Max Heap 為完全二元樹，且父節點鍵值 $\ge$ 子節點鍵值。
若依序插入建立 (或使用 Linear Time Build Heap)：

```text
          40
        /    \
      30      20
     /  \    /  \
    9    15 8    7
   / \   /
  2   5 4
```
*(註：陣列表示為 [40, 30, 20, 9, 15, 8, 7, 2, 5, 4])*

**三、2-4 Tree**

2-4 Tree 每個節點可儲存 1~3 個鍵值，擁有 2~4 個子節點。所有葉節點在同一層。
依序插入 2, 4, 5, 7, 8, 9, 15, 20, 30, 40：

```text
          [ 8, 20 ]
        /     |     \
   [ 4, 5 ] [ 9, 15 ] [ 30, 40 ]
   /  |  \  /  |  \   /   |   \
 (2) (7) ( )  ( ) ( ) ( )  ( )
```
*(更精確的畫法是將鍵值放入節點，滿了就分裂)*

最終結構：
根節點：`[ 8, 20 ]`
子節點 1：`[ 4, 5 ]` (含鍵值 2, 7 的子樹指標，若為葉節點則直接包含)
子節點 2：`[ 9, 15 ]`
子節點 3：`[ 30, 40 ]`

---

### 題目 2：Huffman Tree 建構 (113年地方特考三等)

#### 📖 原題

> **題目**：假設一份文件包含 6 個字元，其出現頻率分別為：a: 40k, b: 20k, c: 15k, d: 10k, e: 8k, f: 7k。
> (一) 請畫出 Huffman coding 建立的樹。（10 分）
> (二) 計算編碼後的總位元數（total bits）。（5 分）
> (三) 相較於使用固定長度編碼（fixed-length coding），Huffman coding 節省了多少空間？（5 分）

#### 🎯 答題架構分析

1.  **建樹過程**：每次取頻率最小的兩個合併。
    - 排序：f(7), e(8), d(10), c(15), b(20), a(40)
    - 合併 f, e -> 15
    - 合併 d, 15(fe) -> 25
    - 合併 c, b -> 35 (錯，應取最小兩者)
    - **正確步驟**：
      1. {7, 8, 10, 15, 20, 40}
      2. 取 7, 8 $\rightarrow$ 15. Pool: {10, 15, 15(new), 20, 40}
      3. 取 10, 15 $\rightarrow$ 25. Pool: {15(new), 20, 25(new), 40}
      4. 取 15, 20 $\rightarrow$ 35. Pool: {25, 35(new), 40}
      5. 取 25, 35 $\rightarrow$ 60. Pool: {40, 60(new)}
      6. 取 40, 60 $\rightarrow$ 100.

#### ✍️ 標準答案示範

**解答**：

**一、Huffman Tree 建構**

**Huffman Tree 圖示**：
```text
          100
         /   \
       40(a)  60
             /  \
           25    35
          /  \   /  \
        10(d) 15 15  20(b)
             (c) / \
               7(f) 8(e)
```
*(註：左0右1，編碼如下)*
- a: 0 (1 bit)
- d: 100 (3 bits)
- c: 101 (3 bits)
- f: 1100 (4 bits)
- e: 1101 (4 bits)
- b: 111 (3 bits)

**二、總位元數計算**

- a: $40 \times 1 = 40$
- b: $20 \times 3 = 60$
- c: $15 \times 3 = 45$
- d: $10 \times 3 = 30$
- e: $8 \times 4 = 32$
- f: $7 \times 4 = 28$

總計：$40+60+45+30+32+28 = 235$ k bits。

**三、節省空間計算**

- **固定長度編碼**：6 個字元需 3 bits ($2^2 < 6 \le 2^3$)。
  - 總長度 = $(40+20+15+10+8+7) \times 3 = 100 \times 3 = 300$ k bits。
- **Huffman 編碼**：235 k bits。
- **節省量**：$300 - 235 = 65$ k bits。
- **節省比例**：$65 / 300 \approx 21.67\%$。

---

### 題目 3：AVL Tree 插入與旋轉 (112年地方特考三等)

#### 📖 原題

> **題目**：請畫出將下列鍵值依序插入空的 AVL Tree 的過程，並說明每次插入後是否需要旋轉（Rotation）以及旋轉的類型（LL, RR, LR, RL）：
> 鍵值序列：10, 20, 30, 40, 50, 25
> （20 分）

#### 🎯 答題架構分析

需逐步畫出插入過程，並在不平衡時標示旋轉類型。
1. 10: OK
2. 20: OK
3. 30: 不平衡 (10-20-30 RR型) -> 左旋 (RR Rotation)
4. 40: OK
5. 50: 不平衡 (30-40-50 RR型) -> 左旋
6. 25: 不平衡 (20-40-30 RL型) -> 先右旋再左旋 (RL Rotation)

#### ✍️ 標準答案示範

**解答**：

**1. 插入 10, 20**
```text
  10
    \
    20
```
(平衡，無旋轉)

**2. 插入 30**
```text
  10 (BF=-2)
    \
    20 (BF=-1)
      \
      30
```
**不平衡類型：RR** (右右失衡)
**調整：單次左旋 (Left Rotation)** 以 20 為軸。
```text
    20
   /  \
  10   30
```

**3. 插入 40**
```text
    20
   /  \
  10   30 (BF=-1)
         \
         40
```
(平衡，無旋轉)

**4. 插入 50**
```text
    20 (BF=-2)
   /  \
  10   30 (BF=-2)
         \
         40 (BF=-1)
           \
           50
```
**不平衡類型：RR** (在子樹 30-40-50 發生)
**調整：單次左旋** 以 40 為軸。
```text
    20
   /  \
  10   40
       / \
      30  50
```

**5. 插入 25**
```text
    20 (BF=-2)
   /  \
  10   40 (BF=1)
       / \
      30  50
     /
    25
```
**不平衡類型：RL** (根節點 20 的右子樹 40 的左子樹 30 導致)
**調整：RL 雙旋轉 (Double Rotation)**
1. 先對右子樹 (40) 進行 **右旋 (Right Rotation)**。
2. 再對根 (20) 進行 **左旋 (Left Rotation)**。

**最終結構**：
```text
      30
     /  \
   20    40
  /  \     \
 10  25    50
```

---

### 題目 4：Expression Tree 與走訪 (111年地方特考三等)

#### 📖 原題

> **題目**：給定一個算術運算式：(A + B) * (C - D) / E
> (一) 請畫出對應的算術運算樹（Expression Tree）。（10 分）
> (二) 請列出該樹的前序（Preorder）、中序（Inorder）和後序（Postorder）走訪結果。（10 分）

#### ✍️ 標準答案示範

**解答**：

**一、Expression Tree**

```text
        /
      /   \
     *     E
    / \
   +   -
  / \ / \
 A  B C  D
```

**二、走訪結果**

1.  **前序 (Preorder)**：`/ * + A B - C D E`
2.  **中序 (Inorder)**：`A + B * C - D / E`
3.  **後序 (Postorder)**：`A B + C D - * E /`

---

### 題目 5：m-ary Tree 高度與節點數 (111年地方特考三等)

#### 📖 原題

> **題目**：對於一個 m-ary Tree（每個節點最多有 m 個子節點）：
> (一) 若高度為 h（根節點高度為 1），請推導出該樹最多可以有多少個節點。（10 分）
> (二) 若有 n 個節點，請推導出該樹的最小高度。（10 分）

#### ✍️ 標準答案示範

**解答**：

**一、最大節點數推導**

$$N = \frac{m^h - 1}{m - 1}$$

**二、最小高度推導**

$$h = \lceil \log_m(n(m - 1) + 1) \rceil$$

---

### 題目 6：Min Heap 操作 (111年地方特考三等)

#### 📖 原題

> **題目**：給定一個空的 Min Heap，請依序執行下列操作，並畫出每次操作後的 Heap 結構（以二元樹形式表示）：
> Insert(5), Insert(3), Insert(8), Insert(1), Insert(9), DeleteMin(), Insert(2)
> （20 分）

#### ✍️ 標準答案示範

**解答**：

**(最終結果)**
```text
      2
     / \
    3   8
   / \
  9   5
```

---

### 題目 7：二元樹中序走訪演算法 (110年地方特考三等)

#### 📖 原題

> **題目**：二元樹的走訪（Traversal）通常使用遞迴（Recursion）方式實作。
> (一) 請寫出二元樹中序走訪（Inorder Traversal）的遞迴版本演算法。（10 分）
> (二) 請寫出二元樹中序走訪的非遞迴（Non-recursive）版本演算法，並說明需使用何種資料結構輔助。（15 分）

#### ✍️ 標準答案示範

**解答**：

**一、遞迴版本 (C/C++)**

```c
void Inorder(TreeNode* root) {
    if (root != NULL) {
        Inorder(root->left);
        printf("%d ", root->data);
        Inorder(root->right);
    }
}
```

**二、非遞迴版本**

需使用 **堆疊 (Stack)**。

```c
void InorderNonRecursive(TreeNode* root) {
    Stack S = CreateStack();
    TreeNode* current = root;
    while (current != NULL || !IsEmpty(S)) {
        while (current != NULL) {
            Push(S, current);
            current = current->left;
        }
        if (!IsEmpty(S)) {
            current = Pop(S);
            printf("%d ", current->data);
            current = current->right;
        }
    }
}
```

---

### 題目 8：Interval Heap (110年地方特考三等)

#### 📖 原題

> **題目**：Interval Heap 是一種可以用來實作雙端優先佇列（Double-ended Priority Queue）的資料結構。
> (一) 請說明 Interval Heap 的結構特性。（10 分）
> (二) 請描述在 Interval Heap 中插入一個新元素的演算法。（15 分）

#### ✍️ 標準答案示範

**解答**：

**一、Interval Heap 結構特性**

1.  **完全二元樹**。
2.  每個節點包含兩個元素 (min, max)，且 $min \le max$。
3.  **Min Property**：父節點 min $\le$ 子節點 min。
4.  **Max Property**：父節點 max $\ge$ 子節點 max。

**二、插入演算法**

1.  若最後節點未滿，直接放入並比較 min/max。
2.  若最後節點已滿，新增節點。
3.  **Sift Up**：
    - 若 $x <$ Parent.min，與 Parent.min 比較並交換 (Min Heap Sift Up)。
    - 若 $x >$ Parent.max，與 Parent.max 比較並交換 (Max Heap Sift Up)。

---

### 題目 9：複製二元樹演算法 (109年地方特考三等)

#### 📖 原題

> **題目**：請設計一個演算法 copy(root)，用來複製一棵二元樹。該函式接收原二元樹的根節點指標，並回傳複製後新二元樹的根節點指標。
> (一) 請使用 C、C++ 或 Java 寫出此演算法。（15 分）
> (二) 分析其時間複雜度。（10 分）

#### 🎯 答題架構分析

1.  **演算法設計**：使用 **後序走訪 (Postorder Traversal)** 的概念。
    - 先複製左子樹。
    - 再複製右子樹。
    - 最後建立根節點，並連接左右子樹複本。
2.  **複雜度**：每個節點被訪問一次，建立一個新節點。

#### ✍️ 標準答案示範

**解答**：

**一、複製演算法 (C++)**

```cpp
TreeNode* copy(TreeNode* root) {
    // Base Case: 若樹為空，回傳 NULL
    if (root == NULL) {
        return NULL;
    }

    // 1. 建立新節點，複製資料
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    newNode->data = root->data;

    // 2. 遞迴複製左子樹
    newNode->left = copy(root->left);

    // 3. 遞迴複製右子樹
    newNode->right = copy(root->right);

    // 4. 回傳新樹的根節點
    return newNode;
}
```

**二、時間複雜度分析**

- 設二元樹共有 $n$ 個節點。
- 該演算法會對每一個節點進行一次遞迴呼叫。
- 在每次呼叫中，執行的操作（記憶體配置、賦值、指標連接）皆為常數時間 $O(1)$。
- 因此，總時間複雜度為 **$O(n)$**。

---

### 題目 10：B-Tree 定義與插入 (109年地方特考三等)

#### 📖 原題

> **題目**：關於 B-Tree（Order m）：
> (一) 請說明 B-Tree 的定義與特性。（10 分）
> (二) 請畫出將下列資料依序插入一棵 Order 3 的 B-Tree 的過程：
> 20, 40, 50, 30, 15, 10, 25, 35
> （15 分）

#### 🎯 答題架構分析

1.  **定義**：
    - 根節點至少 2 子節點。
    - 非根節點至少 $\lceil m/2 \rceil$ 子節點。
    - 所有葉節點在同一層。
    - 鍵值排序。
2.  **插入過程 (Order 3)**：
    - Order 3 (2-3 Tree)：節點最多 2 個鍵值 (3 個子節點)。
    - 滿了 (3 個鍵值) 就分裂：中間值上提。

#### ✍️ 標準答案示範

**解答**：

**一、B-Tree (Order m) 定義**

1.  **平衡性**：所有葉節點 (Leaf Nodes) 都在同一層。
2.  **節點鍵值數**：每個節點最多有 $m-1$ 個鍵值。
3.  **子節點數**：
    - 根節點：若非葉子，至少有 2 個子節點。
    - 非根內部節點：至少有 $\lceil m/2 \rceil$ 個子節點。
4.  **排序**：節點內的鍵值由小到大排序，且分隔子樹的鍵值範圍。

**二、插入過程 (Order 3, 即 2-3 Tree)**

每個節點最多容納 2 個鍵值。若有 3 個，則需分裂，中間值上提。

1. **Insert 20, 40**: `[20, 40]`
2. **Insert 50**: `[20, 40, 50]` -> 分裂，40 上提。
   ```text
      40
     /  \
   [20] [50]
   ```
3. **Insert 30**: 插入左子樹 `[20, 30]`。
   ```text
      40
     /  \
  [20, 30] [50]
   ```
4. **Insert 15**: 插入左子樹 `[15, 20, 30]` -> 分裂，20 上提。
   ```text
      [20, 40]
     /   |   \
   [15] [30] [50]
   ```
5. **Insert 10**: 插入左子樹 `[10, 15]`。
6. **Insert 25**: 插入中子樹 `[25, 30]`。
7. **Insert 35**: 插入中子樹 `[25, 30, 35]` -> 分裂，30 上提。
   ```text
      [20, 30, 40] -> 根節點滿，分裂，30 上提為新根
   ```
   **最終結構**：
   ```text
          30
        /    \
      20      40
     /  \    /  \
  [10,15] [25] [35] [50]
   ```

---

### 題目 11：AVL Tree 高度計算與插入 (109年地方特考三等)

#### 📖 原題

> **題目**：
> (一) 在一棵高度為 h (h=0, 1, 2, ...) 的 AVL tree 中：
> 1. 高度為 6 之 AVL tree 最多可能有幾個 nodes？最少可能有幾個 nodes？（假設 root 之 h=0）（6 分）
> 2. 假設此樹共有 45 個 nodes。請問此 AVL tree 可能最高之高度及最矮之高度各為何？（6 分）
> (二) 請將下列數字 {17, 60, 24, 5, 7} 逐步插入圖 1 的 AVL tree 中，並平衡之。（12 分）
>
> **圖 1 結構**：
> - Root: 14
> - Left Subtree: 8 -> Left: 4
> - Right Subtree: 28 -> Left: 20 (-> Left: 16), Right: 52

#### 🎯 答題架構分析

1.  **高度與節點數關係**：
    - **最多節點**：即為 Full Binary Tree，$N_{max}(h) = 2^{h+1} - 1$。
    - **最少節點**：符合 AVL 定義的最稀疏樹，$N_{min}(h) = N_{min}(h-1) + N_{min}(h-2) + 1$。
2.  **高度推導**：
    - 給定 $N=45$，反推 $h$。
    - 最矮高度：$\lfloor \log_2 N \rfloor$。
    - 最高高度：查表或估算 $N_{min}(h) \le 45$ 的最大 $h$。
3.  **插入操作**：
    - 初始樹：{14, 8, 28, 4, 20, 52, 16}。
    - 依序插入 17, 60, 24, 5, 7，每次插入後檢查 BF 並旋轉。

#### ✍️ 標準答案示範

**解答**：

**一、AVL Tree 高度與節點數計算**

**(1) 高度 h=6 的節點數範圍**

- **最多節點數 (Max Nodes)**：
  當 AVL Tree 為 Full Binary Tree 時節點最多。
  $$N_{max}(6) = 2^{6+1} - 1 = 2^7 - 1 = 127$$

- **最少節點數 (Min Nodes)**：
  令 $N_h$ 為高度 $h$ 的 AVL Tree 最少節點數。
  遞迴關係：$N_h = N_{h-1} + N_{h-2} + 1$
  - $N_0 = 1$
  - $N_1 = 2$
  - $N_2 = 1 + 2 + 1 = 4$
  - $N_3 = 2 + 4 + 1 = 7$
  - $N_4 = 4 + 7 + 1 = 12$
  - $N_5 = 7 + 12 + 1 = 20$
  - $N_6 = 12 + 20 + 1 = 33$
  **答：最多 127 個，最少 33 個。**

**(2) 45 個節點的高度範圍**

- **最矮高度 (Min Height)**：
  發生在 Full Binary Tree 時。
  $h_{min} = \lfloor \log_2 45 \rfloor = 5$ (因為 $2^5=32, 2^6=64$)。
  **答：最矮高度為 5。**

- **最高高度 (Max Height)**：
  發生在最稀疏 AVL Tree 時。
  根據上述 $N_h$ 表：
  - $N_6 = 33$
  - $N_7 = 20 + 33 + 1 = 54$
  因為 $33 \le 45 < 54$，所以高度可以是 6，但達不到 7。
  **答：最高高度為 6。**

**二、逐步插入 {17, 60, 24, 5, 7}**

**初始狀態**：
```text
      14
     /  \
    8    28
   /    /  \
  4    20   52
      /
     16
```

**1. 插入 17**
- 17 < 28, 17 < 20, 17 > 16。插入 16 右邊。
- 路徑：28(L) -> 20(L) -> 16(R) -> 17。
- 檢查平衡：
  - 16: BF=-1
  - 20: BF=2 (左高右低? 不，左子樹高2(16-17)，右子樹高0。BF=2) -> **不平衡**。
  - 不平衡類型：**LR 型** (20左子16，16右子17)。
- **調整 (LR 雙旋轉)**：
  1. 先對 16 左旋 (17 上升)。
  2. 再對 20 右旋 (17 上升取代 20)。
```text
      14
     /  \
    8    28
   /    /  \
  4    17   52
      /  \
     16  20
```

**2. 插入 60**
- 60 > 14, 60 > 28, 60 > 52。插入 52 右邊。
- 平衡檢查：OK。
```text
      14
     /  \
    8    28 (BF=-1)
   /    /  \
  4    17   52
      /  \    \
     16  20   60
```

**3. 插入 24**
- 24 > 14, 24 < 28, 24 > 17, 24 > 20。插入 20 右邊。
- 平衡檢查：OK。
```text
      14
     /  \
    8    28
   /    /  \
  4    17   52
      /  \    \
     16  20   60
           \
           24
```

**4. 插入 5**
- 5 < 14, 5 < 8, 5 > 4。插入 4 右邊。
- 平衡檢查：
  - 4 (BF=-1)
  - 8 (BF=2) -> 左子樹高(4-5)，右子樹空。**不平衡**。
  - 不平衡類型：**LR 型** (8左子4，4右子5)。
- **調整 (LR 雙旋轉)**：
  1. 對 4 左旋 (5 上升)。
  2. 對 8 右旋 (5 上升取代 8)。
```text
      14
     /  \
    5    28
   / \  /  \
  4  8 17   52
      /  \    \
     16  20   60
           \
           24
```

**5. 插入 7**
- 7 < 14, 7 > 5, 7 < 8。插入 8 左邊。
- 平衡檢查：
  - 8 (BF=1)
  - 5 (BF=-1)
  - 14 (BF=2) -> 左子樹高3 (5-8-7)，右子樹高4 (28-17-20-24)。BF = 3-4 = -1。OK。
  - 等等，檢查 28 子樹高度：
    - 左 (17-20-24) 高度 3。
    - 右 (52-60) 高度 2。
    - 28 的 BF = 1。
  - 檢查 14 的 BF：左高 3，右高 4。BF = -1。OK。
  - **全樹平衡，無需旋轉。**

**最終結構**：
```text
       14
     /    \
    5      28
   / \    /  \
  4   8  17   52
     /  /  \    \
    7  16  20   60
             \
             24
```


---

### 題目 12：2-3-4 Tree 插入 (108年地方特考三等)

#### 📖 原題

> **題目**：請畫出將下列數據依序插入一棵空的 2-3-4 Tree 的過程：
> 10, 20, 30, 40, 50, 60, 70, 80
> （20 分）

#### 🎯 答題架構分析

2-3-4 Tree (Order 4 B-Tree)：
- 節點最多 3 個鍵值。
- **Preemptive Split (預先分裂)**：在往下走訪時，若遇到滿節點 (3鍵)，先分裂再插入。這與標準 B-Tree (插入後才分裂) 不同，優點是插入時不需回溯分裂。

#### ✍️ 標準答案示範

**解答**：

1. **10, 20, 30**: `[10, 20, 30]` (滿)
2. **Insert 40**:
   - 根節點滿，先分裂。20 上提。
   - 變為：20 為根，左 `[10]`，右 `[30]`。
   - 40 插入右邊：`[30, 40]`。
   ```text
      20
     /  \
   [10] [30, 40]
   ```
3. **Insert 50**: 插入右邊 `[30, 40, 50]` (滿)。
4. **Insert 60**:
   - 遇到右子節點 `[30, 40, 50]` 滿，先分裂。40 上提至根。
   - 根變為 `[20, 40]`。
   - 60 插入最右邊：`[50, 60]`。
   ```text
      [20, 40]
     /   |   \
   [10] [30] [50, 60]
   ```
5. **Insert 70**: 插入最右邊 `[50, 60, 70]` (滿)。
6. **Insert 80**:
   - 遇到最右子節點 `[50, 60, 70]` 滿，先分裂。60 上提至根。
   - 根變為 `[20, 40, 60]` (滿)。
   - 80 插入最右邊：`[70, 80]`。
   ```text
        [20, 40, 60]
       /   |   |   \
     [10] [30] [50] [70, 80]
   ```

---

### 題目 13：Fibonacci 遞迴呼叫樹 (107年地方特考三等)

#### 📖 原題

> **題目**：考慮計算費氏數列（Fibonacci Sequence）的遞迴函式：Fib(n) = Fib(n-1) + Fib(n-2)...
> (一) 請畫出計算 Fib(5) 時的遞迴呼叫樹（Recursion Tree）。（5 分）
> (二) 請分析計算 Fib(n) 所需的遞迴呼叫次數。（5 分）

#### 🎯 答題架構分析

1.  **呼叫樹**：
    - F(5) -> F(4), F(3)
    - F(4) -> F(3), F(2)
    - ...直到 F(1), F(0)。
2.  **呼叫次數**：
    - 指數級成長。$T(n) \approx 1.618^n$。

#### ✍️ 標準答案示範

**解答**：

**一、遞迴呼叫樹 (Recursion Tree)**

```text
           F(5)
         /      \
      F(4)      F(3)
     /    \    /    \
   F(3)  F(2) F(2)  F(1)
   /  \  /  \ /  \
 F(2) F(1) F(1) F(0) ...
 /  \
F(1) F(0)
```
*(註：F(1)與F(0)為終止條件)*

**二、遞迴呼叫次數分析**

- 設 $C(n)$ 為計算 Fib(n) 的呼叫次數。
- $C(n) = C(n-1) + C(n-2) + 1$ (1 為本身的呼叫)。
- 這與費氏數列本身的成長類似，約為 $O(\phi^n)$，其中 $\phi = \frac{1+\sqrt{5}}{2} \approx 1.618$ (黃金比例)。
- 故時間複雜度為 **指數級 $O(2^n)$**。

---

### 題目 14：Complete Binary Tree 陣列表示 (106年地方特考三等)

#### 📖 原題

> **題目**：若使用一維陣列（Array）來儲存一棵 Complete Binary Tree，假設根節點儲存在索引 1 的位置。
> (一) 對於任意節點 i，請列出其左子節點、右子節點和父節點的索引公式。（10 分）
> (二) 若該樹不是 Complete Binary Tree，使用此方法的缺點為何？（10 分）

#### 🎯 答題架構分析

1.  **公式**：
    - Left: $2i$
    - Right: $2i+1$
    - Parent: $\lfloor i/2 \rfloor$
2.  **缺點**：
    - 稀疏矩陣問題 (Sparse)。
    - 空間浪費。

#### ✍️ 標準答案示範

**解答**：

**一、索引公式 (1-based Indexing)**

假設節點索引為 $i$：
1.  **左子節點 (Left Child)**：$2i$ (若 $2i > n$ 則無左子)
2.  **右子節點 (Right Child)**：$2i + 1$ (若 $2i+1 > n$ 則無右子)
3.  **父節點 (Parent)**：$\lfloor i / 2 \rfloor$ (若 $i=1$ 則無父節點)

**二、非 Complete Binary Tree 的缺點**

若樹為 **Skewed Tree (歪斜樹)** 或稀疏樹，會造成嚴重的 **記憶體空間浪費**。
例如：一棵深度為 $k$ 的右歪斜樹 (只有右子節點)，雖然只有 $k$ 個節點，但最後一個節點的索引值將高達 $2^{k-1}$。陣列必須宣告到這麼大，中間會有大量空洞 (Empty entries)。

---

### 題目 15：由走訪結果重建二元樹 (105年地方特考三等)

#### 📖 原題

> **題目**：已知一棵二元樹的中序走訪（Inorder）結果為：D, B, E, A, F, C, G；前序走訪（Preorder）結果為：A, B, D, E, C, F, G。
> (一) 請畫出此二元樹。（15 分）
> (二) 若只給定前序和後序走訪結果，是否能唯一決定一棵二元樹？請舉例說明。（10 分）

#### 🎯 答題架構分析

1.  **重建**：
    - Preorder 第一個是 Root (A)。
    - 在 Inorder 找 A，左邊 (D, B, E) 是左子樹，右邊 (F, C, G) 是右子樹。
    - 遞迴處理。
2.  **唯一性**：否。
    - 例子：只有兩個節點 A, B。A 是根。若 B 是左子或右子，Preorder 都是 AB，Postorder 都是 BA。無法區分。

#### ✍️ 標準答案示範

**解答**：

**一、重建二元樹**

1. **Root**: Preorder 第一個為 **A**。
2. **分割**: Inorder 中 A 的左邊 `{D, B, E}` 為左子樹，右邊 `{F, C, G}` 為右子樹。
3. **左子樹**: Preorder 下一個是 **B** (左子樹根)。Inorder 中 B 左邊 `{D}`，右邊 `{E}`。
4. **右子樹**: Preorder 剩下 `{C, F, G}`，第一個是 **C** (右子樹根)。Inorder 中 C 左邊 `{F}`，右邊 `{G}`。

**結果圖示**：
```text
      A
     / \
    B   C
   / \ / \
  D  E F  G
```

**二、Preorder + Postorder 無法唯一決定**

**否**，無法唯一決定。
**反例**：
- 樹 1：根 A，左子 B。
  - Preorder: A, B
  - Postorder: B, A
- 樹 2：根 A，右子 B。
  - Preorder: A, B
  - Postorder: B, A

兩棵樹結構不同，但走訪結果完全相同，故無法區分。

---

### 題目 16：IF 指令二元樹優化 (104年地方特考三等)

#### 📖 原題

> **題目**：(簡述) 依據成績分級 (A, B, C, D, F) 的 IF-ELSE 程式。機率分別為 A(0.05), B(0.30), C(0.50), D(0.1), F(0.05)。
> (一) 畫出原程式的二元樹並分析比較次數。
> (二) 用最佳化二元樹修正，畫出並分析比較次數。

#### 🎯 答題架構分析

1.  **原程式**：
    - IF < 60 (F) -> else IF < 70 (D) -> ...
    - 這是歪斜樹 (Skewed)。
    - 期望值計算：$\sum P_i \times \text{Depth}_i$。
2.  **最佳化**：
    - 使用 **Huffman Tree** 概念，高機率的 (C: 0.50) 放在靠近根部。
    - 構造 Optimal Binary Search Tree (OBST) 或 Huffman Tree。

#### ✍️ 標準答案示範

**解答**：

**一、原程式分析**

程式邏輯：先比 <60 (F)，再比 <70 (D)，再比 <80 (C)，再比 <90 (B)，最後 A。
樹狀結構 (右歪斜)：
```text
      <60?
     /    \
   F(0.05) <70?
          /    \
        D(0.1) <80?
               /    \
             C(0.5) <90?
                    /    \
                  B(0.3) A(0.05)
```
**平均比較次數**：
$1(0.05) + 2(0.1) + 3(0.5) + 4(0.3) + 4(0.05)$
$= 0.05 + 0.2 + 1.5 + 1.2 + 0.2 = 3.15$ 次。

**二、最佳化二元樹 (Huffman/OBST)**

將高機率的 C(0.5) 和 B(0.3) 往上提。
最佳策略是先判斷是否 < 80 (區分 C, D, F 與 B, A)。

**優化結構**：
```text
             <80?
           /      \
        <70?       <90?
       /   \      /    \
    <60?  C(0.5) B(0.3) A(0.05)
    /  \
 F(0.05) D(0.1)
```
**平均比較次數**：
- C(0.5): 2次
- B(0.3): 2次
- A(0.05): 2次
- D(0.1): 3次
- F(0.05): 3次
總計：$2(0.5) + 2(0.3) + 2(0.05) + 3(0.1) + 3(0.05)$
$= 1.0 + 0.6 + 0.1 + 0.3 + 0.15 = 2.15$ 次。

**改善幅度**：從 3.15 降至 2.15，效率提升顯著。

---

### 題目 12：運算式樹與走訪 (104年地方特考三等)

#### 📖 原題

> **題目**：一運算式 (expression) 為：`-a+(z+f)/y-b*a/c+d`，請依運算元優先順序：
> (一) 繪出其二元樹 (binary tree)。（10 分）
> (二) 請列出此二元樹的前序走訪 (preorder traversal)。（5 分）
> (三) 請列出此二元樹的廣度優先走訪 (breadth-first search traversal)。（5 分）

#### 🎯 答題架構分析

1.  **建構二元樹**：
    - 運算子優先權：`()` > `unary -` > `* /` > `+ -`。
    - 注意結合性：通常由左至右。
    - 運算式解析：
      1. `-a` (負號 a)
      2. `(z+f)`
      3. `(z+f)/y`
      4. `b*a`
      5. `(b*a)/c`
      6. `-a + (z+f)/y`
      7. `... - (b*a)/c`
      8. `... + d`
    - 根節點應為最後執行的運算子。
    - 觀察：`((-a) + ((z+f)/y)) - ((b*a)/c) + d`
    - 這裡有連續的 `+` 和 `-`。依左至右結合：
      - Root 1: `+` (左: `-a`, 右: `(z+f)/y`) -> 錯，這是第一部分。
      - 整個式子：`X - Y + Z`。
      - 先算 `X - Y`，再 `+ Z`。
      - 所以最上層 Root 是最後的 `+` (連接 `d`)。
      - 左子樹是 `-` (連接 `X` 和 `Y`)。
      - `X` 是 `+` (連接 `-a` 和 `...`)。

    - **更正解析順序**：
      - `-a + (z+f)/y - b*a/c + d`
      - 令 `T1 = -a`
      - 令 `T2 = (z+f)/y`
      - 令 `T3 = b*a/c`
      - 式子變為：`T1 + T2 - T3 + d`
      - 由左至右：
        1. `(T1 + T2)`
        2. `(T1 + T2) - T3`
        3. `((T1 + T2) - T3) + d`
      - **Root**: `+` (右子樹 `d`)
      - **左子樹**: `-` (右子樹 `T3`)
      - **左左子樹**: `+` (左 `T1`, 右 `T2`)

2.  **走訪**：
    - **Preorder**: Root -> Left -> Right。
    - **BFS**: 層序走訪。

#### ✍️ 標準答案示範

**解答**：

**一、二元樹 (Expression Tree)**

運算式：`((-a) + ((z+f)/y)) - ((b*a)/c) + d`

結構如下：
- **Root**: `+` (最右邊的加號)
  - **Right**: `d`
  - **Left**: `-` (減號)
    - **Right**: `/` (除號，對應 `b*a/c`)
      - **Left**: `*`
        - **Left**: `b`
        - **Right**: `a`
      - **Right**: `c`
    - **Left**: `+` (加號，對應 `-a + ...`)
      - **Left**: `-` (單元運算子負號，或視為 `0-a`，題目寫 `-a` 通常指 Unary Minus)
        - **Right**: `a` (或是左子樹空，右子樹 a)
      - **Right**: `/`
        - **Left**: `+`
          - **Left**: `z`
          - **Right**: `f`
        - **Right**: `y`

**樹狀圖**：
```text
          +
        /   \
       -     d
     /   \
    +     /
   / \   / \
  -   / *   c
  |  / \ / \
  a +  y b  a
   / \
  z   f
```
*(註：單元運算子 `-` 通常作為只有一個子節點的節點，或視為 `0-a`。此處畫為單子節點)*

**二、前序走訪 (Preorder Traversal)**

順序：根 -> 左 -> 右
`+ - + - a / + z f y / * b a c d`

**三、廣度優先走訪 (BFS Traversal)**

順序：由上而下，由左而右
Level 1: `+`
Level 2: `-`, `d`
Level 3: `+`, `/`
Level 4: `-`, `/`, `*`, `c`
Level 5: `a`, `+`, `y`, `b`, `a`
Level 6: `z`, `f`

**BFS 序列**：`+, -, d, +, /, -, /, *, c, a, +, y, b, a, z, f`

---

## 4. 📖 歷屆精選題庫

### 一、平衡樹與進階樹結構 (10題)

1.  ⭐⭐⭐⭐ **AVL Tree 插入與旋轉** (112年地方特考三等)
2.  ⭐⭐⭐⭐ **AVL, Heap, 2-4 Tree 繪圖比較** (113年地方特考三等)
3.  ⭐⭐⭐⭐ **B-Tree 定義與插入** (109年地方特考三等)
4.  ⭐⭐⭐⭐ **2-3-4 Tree 插入過程** (108年地方特考三等)
5.  ⭐⭐⭐⭐ **AVL Tree 高度與節點數計算** (109年地方特考三等)
6.  ⭐⭐⭐ **Interval Heap 結構與插入** (110年地方特考三等)
7.  ⭐⭐⭐ **m-ary Tree 高度推導** (111年地方特考三等)
8.  ⭐⭐⭐ **Complete Binary Tree 陣列表示** (106年地方特考三等)
9.  ⭐⭐⭐ **複製二元樹演算法** (109年地方特考三等)
10. ⭐⭐⭐ **Fibonacci 遞迴呼叫樹** (107年地方特考三等)

### 二、堆積與 Huffman 編碼 (6題)

1.  ⭐⭐⭐ **Huffman Tree 建構與空間節省** (113年地方特考三等)
2.  ⭐⭐⭐ **Min Heap 插入與刪除操作** (111年地方特考三等)
3.  ⭐⭐⭐ **IF 指令最佳化 (Huffman 概念)** (104年地方特考三等)
4.  ⭐⭐⭐ **Max Heap 建立與排序** (106年地方特考三等)
5.  ⭐⭐⭐ **Min-Max Heap 概念** (105年地方特考三等)
6.  ⭐⭐⭐ **Priority Queue 應用** (108年地方特考三等)

### 三、樹的走訪與重建 (6題)

1.  ⭐⭐⭐ **Expression Tree 建構與走訪** (111年地方特考三等)
2.  ⭐⭐⭐ **二元樹中序走訪 (遞迴/非遞迴)** (110年地方特考三等)
3.  ⭐⭐⭐ **由 Inorder/Preorder 重建二元樹** (105年地方特考三等)
4.  ⭐⭐⭐ **二元樹走訪還原唯一性討論** (105年地方特考三等)
5.  ⭐⭐⭐ **Threaded Binary Tree 概念** (104年地方特考三等)
6.  ⭐⭐⭐ **樹的非遞迴走訪實作** (107年地方特考三等)

---

## 5. 💡 答題技巧總結

### 時間分配建議

- **25分題 (如 AVL 插入、B-Tree 繪圖)**：建議作答時間 20-25 分鐘。
  - **繪圖題**：務必預留空間，步驟圖至少畫出關鍵轉折 (如旋轉前、旋轉後)。
  - **演算法題**：先寫虛擬碼 (Pseudo-code) 或步驟說明，再寫程式碼 (C/C++)。

### 分數取捨策略

**優先寫 (高CP值)**：
- ✅ **Heap 操作**：步驟簡單，不易出錯，分數好拿。
- ✅ **Huffman Tree**：規則明確，計算量小。
- ✅ **走訪結果**：Preorder/Inorder/Postorder 寫出序列即可得分。

**小心寫 (易失分)**：
- ⚠️ **AVL/B-Tree 插入**：步驟多，中間錯一步全錯。建議在草稿紙上畫完確認無誤再謄寫。
- ⚠️ **遞迴演算法**：Base case 容易忘記，需特別檢查。
- ⚠️ **複雜度證明**：若推導不出來，至少寫出結論 (如 $O(\log N)$)。

### 加分技巧

- 📊 **圖文並茂**：樹狀結構題目，圖比文字重要。每個步驟的圖都要標示清楚 (如 "執行 LL 旋轉")。
- 📈 **比較表格**：若問資料結構比較 (如 AVL vs B-Tree)，畫表格列出高度、操作複雜度、應用場景。
- 🔢 **檢查平衡因子**：畫 AVL 時，在節點旁標註 BF 值 (如 +1, -1)，顯示你有在檢查平衡。

---

## 6. 📚 參考資源

### 經典教材
- **Fundamentals of Data Structures in C** (Horowitz, Sahni, Anderson-Freed) - 聖經本
- **Introduction to Algorithms** (CLRS) - 演算法權威

### 線上工具 (視覺化學習)
- **Data Structure Visualizations (USFCA)**: 提供 AVL, B-Tree, Heap 的動態操作演示，非常適合理解旋轉與分裂過程。
- **VisuAlgo**: 演算法視覺化平台。

### 實務應用
- **資料庫索引**: B+ Tree 在 DBMS 中的應用。
- **記憶體管理**: Heap 在 OS 中的角色。
- **壓縮軟體**: Huffman Coding 在 ZIP 壓縮中的應用。

